=head1 NAME

PDL::BadValues - Discussion of bad value support in PDL

=head1 DESCRIPTION

=head2 What are bad values and why should I bother with them?

Sometimes it's useful to be able to specify a certain value is 'bad' or 
'missing'; for example CCDs used in astronomy produce 2D images which are not
perfect, since certain areas contain invalid data. Whilst PDL's powerful index
routines and all the complicated business with dataflow, slices, etc etc mean 
that these regions can be ignored in processing, it's awkward to do. It would
be much easier to be able to say C<$c = $a + $b> and leave all the hassle to 
the computer.

If you're not interested in this, then you may (rightly) be concerned 
with how this affects the speed of PDL, since the overhead of checking for a
bad value at each operation can be large. 
Because of this, the code has been written to be as fast as possible -
particularly when operating on piddles which do not contain bad values.
In fact, you should notice essentially no speed difference when working 
with piddles which do not contain bad values.

However, if you do not want bad values, then PDL's C<WITH_BADVAL> 
configuration option comes to the rescue; if set to 0 or undef, the bad-value 
support is ignored.
About the only time I think you'll need to use this - I admit, I'm biased ;) -
is if you have limited disk or memory space, since the size of the code
is increased (see below).

You may also ask 'well, my computer supports IEEE NaN, so I already have this'.
Well, yes and no - many routines, such as C<y=sin(x)>, will propogate NaN's 
without the user having to code differently, but routines such as C<qsort>, or
finding the median of an array, need to be re-coded to handle bad values.
Currently we do not use NaN values, but it's a priority to look into this.

=head2 Code increase due to bad values

On an i386 machine running linux and perl 5.005_03, I measured the 
following sizes (the Slatec code was compiled in, but none of the other 
options: eg Karma, FFTW, GSL, and 3d were): 

=over 4

=item WITH_BADVAL = 0

Size of blib directory after a successful make = B<4963 kb>:
blib/arch = 2485 kb and blib/lib = 1587 kb.

=item WITH_BADVAL = 1

Size of blib directory after a successful make = B<5723 kb>:
blib/arch = 3178 kb and blib/lib = 1613 kb.

=back

So, the overall increase is I<only> 15% - not much to pay for all
the wonders that bad values provides ;)

The source code used for this test had the vast majority of the core routines 
(eg those in Basic/) converted to use bad values, whilst very few of the 'external' 
routines (ie everything else in the PDL distribution) had been changed.

=head2 A quick overview

C<demo bad> within L<perldl|PDL::perldl> gives a demonstration of some of the things
possible with bad values.

See L<PDL::Bad> for useful routines for working with bad values and F<t/bad.t>
to see them in action.

The intention is to:

=over 4

=item *

not significantly affect PDL for users who don't want bad value support

=item *

be as fast as possible when bad value support is required

=back 

If you never want bad value support, then you set C<WITH_BADVAL> to 0 in 
F<perldl.conf>; PDL then has no bad value support compiled in, so will be as fast
as it used to be.

However, in most cases, the bad value support has a negligible affect on speed,
so you should set C<WITH_CONFIG> to 1! One exception is if you are low on memory,
since the amount of code produced is larger (but only by about 15% - see
L<Code increase due to bad values>).

To find out if PDL has been compiled with bad value support, look at the values
of either C<$PDL::Config{WITH_BADVAL}> or C<$PDL::Bad::Status> - if true then
it has been.

To find out if a routine supports bad values, use the C<badinfo> command in
L<perldl|PDL::perldl> or the C<-b> option to L<pdldoc|PDL::pdldoc>. 
This facility is currently a 'proof of concept' (or, more realistically, 
a quick hack) so expect it to be rough around the edges.

Each piddle contains a flag - accessible via C<$pdl-E<gt>badflag> - to say 
whether there's any bad data present: 

=over 4

=item *

If B<false/0>, which means there's no bad data here, the code supplied by the 
C<Code> option to C<pp_def()> is executed. This means that the speed should be 
very close to that obtained with C<WITH_BADVAL=0>, since the only overhead is 
several accesses to a bit in the piddles state variable.

=item *

If B<true/1>, then this says there I<MAY> be bad data in the piddle, so use the
code in the C<BadCode> option (assuming that the C<pp_def()> for this routine 
has been updated to have a BadCode key). 
You get all the advantages of threading, as with the C<Code> option, 
but it will run slower since you are going to have to handle the presence of bad values.

=back

If you create a piddle, it will have its bad-value flag set to 0. To change 
this, use C<$pdl-E<gt>badflag($new_bad_status)>, where C<$new_bad_status> can be 0 or 1.
When a routine creates a piddle, it's bad-value flag will depend on the input
piddles: unless over-ridden (see the C<CopyBadStatusCode> option to C<pp_def>), the 
bad-value flag will be set true if any of the input piddles contain bad values.

I<NOTE>: propogation of the badflag

If you change the badflag of a piddle, this change is propogated to all
the I<children> of a piddle, so

   perldl> $a = zeroes(20,30);
   perldl> $b = $a->slice('0:10,0:10');
   perldl> $c = $b->slice(',(2)');
   perldl> print ">>c: ", $c->badflag, "\n";
   >>c: 0
   perldl> $a->badflag(1);
   perldl> print ">>c: ", $c->badflag, "\n";
   >>c: 1

I<No> change is made to the parents of a piddle, so

   perldl> print ">>a: ", $a->badflag, "\n";
   >>a: 1
   perldl> $c->badflag(0);
   perldl> print ">>a: ", $a->badflag, "\n";
   >>a: 1

Thoughts:

=over 4

=item *

the badflag can ONLY be cleared IF a piddle has NO parents,
and that this change will propogate to all the children of that
piddle. I am not so keen on this anymore (too awkward to code, for
one).

=item *

C<$a-E<gt>badflag(1)> should propogate the badflag to BOTH parents and
children.

=back

This wouldn't be hard to implement. Does it make sense though? There's also
the issue of what happens if you change the badvalue of a piddle - should
these propogate to children/parents (yes) or whether you should only be
able to change the badvalue at the 'top' level - ie those piddles which do
not have parents.

The C<orig_badvalue()> method returns the compile-time value for a given 
datatype. It works on piddles, PDL::Type objects, and numbers - eg

  $pdl->orig_badvalue(), byte->orig_badvalue(), and orig_badvalue(4).

It also has a horrible name...

To get the current bad value, use the C<badvalue()> method - it has the same
syntax as C<orig_badvalue()>.

To change the current bad value, supply the new number to badvalue - eg

  $pdl->badvalue(2.3), byte->badvalue(2), badvalue(5,-3e34). 

I<Note>: the value is silently converted to the correct C type, and
returned - ie C<byte-E<gt>badvalue(2.3e34)> returns 255 on my solaris machine.

Note that changes to the bad value are NOT propogated to previously-created
piddles - they will still have the bad value set, but suddenly the elements
that were bad will become 'good', but containing the old bad value.
See discussion below.

=head2 A bad value for each piddle, and related issues

Currently, there is one bad value for each datatype. The code is written so 
that we could have a separate bad value for each piddle (stored in the 
pdl structure) - this would then remove the current problem of:

 perldl> $a = byte( 1, 2, byte->badvalue, 4, 5 );
 perldl> p $a;
 [1 2 255 4 5]
 perldl> $a->badflag(1)
 perldl> p $a;
 [1 2 BAD 4 5]
 perldl> byte->badvalue(0);
 perldl> p $a;
 [1 2 255 4 5]

ie the bad value in C<$a> has lost its I<bad> status using the current 
implementation. 

The overhead would be too large to have 

   byte->badvalue($newval)

propogate through C<all> bad piddles and update their bad values.
We could save a 'time' value in the pdl and then automatically update the bad value
of a piddle if we find it's 'time' is older than the 'time' of the default bad
value. But that would be slow and probably rather painful.

However, I think that having a per-piddle bad value would cause too much
code overhead (not in the current implementation but this needs looking at).

Bottom line - per-piddle bad values are low on the list of my priorities.

=head1 Implementation details

Various bits of code use either F<perldl.conf> or F<PDL::Config> to find out 
whether to support bad values (user code can examine the value of 
C<$PDL::Bad::Status>).

A new flag has been added to the state of a piddle - C<PDL_BADVAL>. If unset, then
the piddle does not contain bad values, and so all the support code can be 
ignored. If set, it does not guarantee that bad values are present, just that
they should be checked for. Thanks to help from Christian, C<badflag()> - which 
sets/clears this flag (see F<Basic/Bad/bad.pd>) - will update I<ALL> the 
children/grandchildren/etc of a piddle if its state changes (see 
C<badflag> in F<Basic/Bad/bad.pd> and
C<propogate_badflag> in F<Basic/Core/Core.xs.PL>). 
It's not clear what to do with parents: I can see the reason for propogating a 
'set badflag' request to parents, but I think a child should NOT be able to clear 
the badflag of a parent. 
Actually, I'm vacillating on this one (plus it looks like there's the
chance of infinite loops if code is done inplace, or I messed up somewhere!).

There's also the issue of what happens when you change the bad value for a piddle.

The C<pdl_trans> structure has been extended to include an integer value,
C<bvalflag>, which acts as a switch to tell the code whether to handle bad values
or not. This value is set if any of the input piddles have their C<PDL_BADVAL> 
flag set (although this code can be replaced by setting C<FindBadStateCode> in 
pp_def). I tried using the flags field - instead of adding a new variable -
in the trans struct, but it didn't work (the bit was occasionally getting 
cleared during calls to C<PDL-E<gt>make_trans_mutual()> and I couldn't be 
bothered to track it down). 

The bad values are now stored in a structure within the Core PDL structure
- C<PDL.bvals> (eg F<Basic/Core/pdlcore.h.PL>); see also 
'typedef badvals' in F<Basic/Core/pdl.h.PL> and the
BOOT code of F<Basic/Core/Core.xs.PL> where the values are initialised to 
(hopefully) sensible values. See F<PDL/Bad/bad.pd> for read/write routines to
these values.

The default/original bad values are set to (taken from the Starlink
distribution):

  #include <float.h>
  #include <limits.h>

  PDL_Byte    ==  UCHAR_MAX
  PDL_Short   ==   SHRT_MIN
  PDL_Ushort  ==  USHRT_MAX
  PDL_Long    ==    INT_MIN
  PDL_Float   ==   -FLT_MAX
  PDL_Double  ==   -DBL_MAX

=head2 How do I change a routine to handle bad values?

Examples can be found in most of the F<*.pd> files in F<Basic/> (and
hopefully many more places soon!). 
Some of the logic might appear a bit unclear - that's probably because it
is! Comments appreciated.

All routines should automatically propogate the bad status flag to output
piddles, unless you declare otherwise.

If a routine explicitly deals with bad values, you must provide this option
to pp_def:

   HandleBad => 1

This ensures that the correct variables are initialised for the C<$ISBAD> etc
macros. It is also used by the automatic document-creation routines to
provide default information on the bad value support of a routine without
the user having to type it themselves (this is in its early stages).

To flag a routine as NOT handling bad values, use 

   HandleBad => 0

This I<should> cause the routine to print a warning if it's sent any piddles
with the bad flag set. Primitive's C<intover> has had this set - since it
would be awkward to convert - but I've not tried it out to see if it works.

If you want to handle bad values but not set the state of all the output
piddles, or if it's only one input piddle that's important, then look
at the PP rules C<NewXSFindBadStatus> and C<NewXSCopyBadStatus> and the
corresponding pp_def options

=over 4

=item FindBadStatusCode 

=item CopyBadStatusCode

=back

A number of routines use this - eg C<isXXXover> (F<bad.pd>) and C<zcover>
(F<primitive.pd>). 

If you have a routine that you want to be able to use as inplace, look
at the routines in F<bad.pd> (or F<ops.pd>)
which use the C<Inplace> option to see how the
bad flag is propogated to children using the C<xxxBadStatusCode> options.
I decided not to automate this as rules would be a
little complex, since not every inplace op will need to propogate the 
badflag (eg unary functions).

If the option

   HandleBad => 1

is given, then the readdata code automatically creates a variable called
C<E<lt>pdl nameE<gt>_badval>, which contains the bad value for that piddle (see
C<get_xsdatapdecl()> in F<Basic/Gen/PP/PdlParObjs.pm>). 
After Tuomas' suggestion, macros have been set up to provide easy access:

  '$ISBAD(a(n=>1))'  expands to '$a(n=>1) == a_badval'
  '$ISGOOD(a())'                '$a()     != a_badval'
  '$SETBAD(bob())'              '$bob()    = bob_badval'

well, the C<$a(...)> is expanded as well. Also, you can use a $ before the
pdl name, if you so wish, but it begins to look like line noise -
eg C<$ISGOOD($a())>.

If you cache a piddle value in a variable -- eg C<index> in F<slices.pd> --
the following routines are useful:

   '$ISBADVAR(c_var,pdl)'     'c_var == pdl_badval'
   '$ISGOODVAR(c_var,pdl)'    'c_var != pdl_badval'
   '$SETBADVAR(c_var,pdl)'    'c_var  = pdl_badval'

The following have been introduced, They may need playing around with to 
improve their use.

  '$PPISBAD(CHILD,[i])           'CHILD_physdatap[i] == CHILD_badval'
  '$PPISGOOD(CHILD,[i])          'CHILD_physdatap[i] != CHILD_badval'
  '$PPSETBAD(CHILD,[i])          'CHILD_physdatap[i]  = CHILD_badval'

This means that you can change

   Code => '$a() = $b() + $c();'

to

   BadCode => 'if ( $ISBAD(b()) || $ISBAD(c()) ) { 
                 $SETBAD(a()); 
               } else {
                 $a() = $b() + $c();
               }'

leaving Code as it is. PP::PDLCode will then create a loop something like

   if ( __trans->bvalflag ) {
        threadloop over BadCode
   } else { 
        threadloop over Code
   }

it's probably easier to just look at the F<.xs> file to see what goes on.

Similar to C<BadCode>, there's C<BadBackCode>, and C<BadRedoDimsCode>.

Handling C<EquivCPOffsCode> is a bit different: under the assumption that the
only access to data is via the C<$EQUIVCPOFFS(i,j)> macro, then we can 
automatically create the 'bad' version of it; see the C<[EquivCPOffsCode]>
and C<[Code]> rules in L<PDL::PP>.

Macros have been provided to provide access to the bad-flag status of 
a pdl:

  '$PDLSTATEISBAD(a)'    -> '($PDL(a)->state & PDL_BADVAL) > 0'
  '$PDLSTATEISGOOD(a)'      '($PDL(a)->state & PDL_BADVAL) == 0'

  '$PDLSTATESETBAD(a)'      '$PDL(a)->state |= PDL_BADVAL'
  '$PDLSTATESETGOOD(a)'     '$PDL(a)->state &= ~PDL_BADVAL'

For use in C<xxxxBadStatusCode> (+ other stuff that goes into the INIT: section)
there are:

  '$SETPDLSTATEBAD(a)'       -> 'a->state |= PDL_BADVAL'
  '$SETPDLSTATEGOOD(a)'      -> 'a->state &= ~PDL_BADVAL'

  '$ISPDLSTATEBAD(a)'        -> '((a->state & PDL_BADVAL) > 0)'
  '$ISPDLSTATEGOOD(a)'       -> '((a->state & PDL_BADVAL) == 0)'

Please note that the current design is based on my failure to understand
what the C<xxx_redodims()>, C<xxx_copy()>, C<xxx_free()> functions that are 
created by PP do (ie I haven't changed them).

=head2 Why not use NaN (IEEE) when present?

Short answer: because I don't know how. 

After talking with Tim Jenness, it looks like it should be able to get
the code to use NaN's as bad values if available - this should mean we can
skip the checks for bad values in the C code, since C<f(x)> with C<x = NaN>
produces C<NaN>, and does it quickly (apparently). However, many routines would
remain unchanged (eg counting the number of bad values, or summing up all the
values).

Basically, PDL::PP would ignore the C<BadCode>/C<BadBackCode>/etc C<pp_def()>
options, just using the C<Code>/... options instead. The supporting code
would still be used (ie for setting the bad flag on output piddles etc).
Some routines would still need explicit code to handle NaN values (eg C<min>, 
C<max>, C<median> - see F<primitive.pd>) - we should be able to use the existing
C<BadCode>/etc values for these.

I have started adding the poorly-named option C<NoBadifNaN =E<gt> 1>
to those routines which should be able to ignore the C<BadCode> options.
It's currently a NOP. 

The C<PDL::PP::BadAccess>, C<PDL::PP::BadVarAccess>, and C<PDL::PP::PPBadAccess> objects 
in F<Basic/PP/PDLCore.pm> I<MAY> need updating to produce different code depending 
on whether NaN support was available or not.

There's also the issue of whether there's a NaN value for each datatype used by
PDL (I'm not sure there is). If not, then those without NaN values would have to
use the original code.

I'd love someone to implement this. 

=head2 What about documentation?

One of the strengths of PDL is it's on-line documentation. The aim is to use
this system to provide informtion on how/if a routine supports bad values:
in many cases C<pp_def()> contains all the information anyway, so the 
function-writer doesn't need to do anything at all! For the cases when this is
not sufficient, there's the C<BadDoc> option. For code written at
the perl level - ie in a .pm file - use the C<=for bad> pod directive.

This information will be available via man/pod2man/html documenation. It's also
accessible from the C<perldl> shell - using the C<badinfo> command - and the C<pdldoc>
shell command - using the C<-b> option.

This support is at a very early stage - ie not much thought has gone into it:
comments are welcome; improvements to the code preferred ;) One awkward problem
is for F<*.pm> code: you have to write a F<*.pm.PL> file which only inserts the 
C<=for bad> directive (+ text) if bad value support is compiled in. In fact, this
is a pain when handling bad values at the perl, rather than PDL::PP, level: perhaps
I should just scrap the C<WITH_BADVAL> option...

=head2 Other notes

The build process has been affected. The following files are
now created during the build:

  Basic/Core/Dev.pm      by mkdev.pl
             pdlcore.h      pdlcore.h.PL
             pdlapi.c       pdlapi.c.PL
             Core.xs        Core.xs.PL
             Core.pm        Core.pm.PL     

We can't use F<Dev.pm.PL>, since F<Dev.pm> is used by the Makefile.PL's,
so it must be created as soon as possible.

Several new files have been added:

  Basic/Pod/Badvalues (ie this file)

  t/bad.t

  Basic/Bad/
  Basic/Bad/Makefile.PL
            bad.pd

etc

=head1 TODO

=head2 Problems

=over 4

=item *

Need to look at C<which()>: how should it handle bad values?

=item *

what to do about C<any($a E<gt> 20)> when all elements of C<$a> are bad:
C<orover($a E<gt> 20)> will produce a bad value, which is then returned
to the caller as a scaler (via C<return $tmp-E<gt>at()>).

=over 4

=item * 

should we just die

=item * 

should we return bad (as it's a scalar we would have to ensure
that it was converted to the type of the input piddle first)

=item *

call a user-defined sub-routine? (supply a default one that dies, say)

=item * 

...

=back

(also for avg,zcheck,... in F<primitive.pd>)

=item *

looks like starlink's byte goes from -127 to 127 - ie not unsigned
(ie L<PDL::IO::NDF>).

=back

=head2 Suggestions

=over 4

=item *

look at the routines to see if can be improved (speed wise) by
use of C<threadloop> construct - I'm thinking in particular about 
those routines that set the state of a piddle within the C<BadCode>,
rather than the C<CopyBadStatusCode>, section.

=item *

NaN support - this would make it *much* faster on machines which
support it (or so I've assumed - does it?) 
I've started labelling routines which could ignore the BadCode
section by C<NoBadifNaN =E<gt> 1>.

See the discussion somewhere above this.

=item *

do any more routines need to be converted to work inplace?

=item *

divide in F<ops.pd> should trap C</ 0> cases as well. also special cases 
for C<sqrt()>, C<log> ... and integration with NaN support

=item *

With the current scheme, it would be possible to have a per-piddle
bad value. However, new piddles would use the default values.
All it would need (I think) is for newly-created piddles to have
their badvalue set to the default value -- I'm just not sure
when new piddles are created within the C code! Then PdlParObj's
get_xsdatapdecl() method needs changing to access the per-piddle
bad value rather than the values stored in the C<PDL-E<gt>bvals>
structure. The actual code wouldn't need changing, as long as it 
was written using the C<$ISGOOD>/C<ISBAD>/C<SETBAD> macros.

It would be redundant if we used NaN support - so maybe we should 
put this on the back-burner until we get Nan support.

I'm moving away from the idea of per-piddle bad values, as I think
it would increase the amount of code in certain cases.

=item *

C<$pdl-E<gt>baddata()> now updates all the children of this piddle
as well. However, not sure what to do with parents, since:

  $b = $a->slice(); 
  $b->baddata(0)

doesn't mean that C<$a> shouldn't have it's badvalue cleared.
however, after

  $b->baddata(1)

it's sensible to assume that the parents now get flagged as
containing bad values.

PERHAPS you can only clear the bad value flag if you are NOT
a child of another piddle, whereas if you set the flag then all
children AND parents should be set as well?

Similarly, if you change the bad value in a piddle, should this
be propogated to parent & children? Or should you only be able to do
this on the 'top-level' piddle? Nasty...

=item *

get some code set up to do benchmarks to see how much things are
slowed down (and to check that I haven't messed things up if
C<WITH_BADVAL> is 0/undef).

=item *

some of the names aren't appealing - I'm thinking of C<orig_badvalue()>
in F<Basic/Bad/bad.pd> in particular. Any suggestions appreciated.

=item *

F<Basic/Core/pdlconv.c.PL> - I don't understand when C<pdl_converttype()>
is called, so I've included a check that prints a message to STDERR
if it's called with a bad piddle. This will need removing at some
point as it's wasted space...

=back

=head1 AUTHOR

Copyright (C) Doug Burke (burke@ifa.hawaii.edu), 2000.
Commercial reproduction of this documentation in a different format is forbidden.

=cut

