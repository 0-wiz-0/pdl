# 
# The contents of Bad.pm depend on whether we have
# bad-value support in PDL.
#

use strict;

# check for bad value support
use PDL::Config;
my $bvalflag = $PDL::Config{WITH_BADVAL} || 0;

########################################################3

my $author = '

=head1 AUTHOR

Doug Burke (burke@ifa.hawaii.edu) and ...

All rights reserved. There is no warranty. You are allowed to
redistribute this software / documentation under certain conditions. For
details, see the file COPYING in the PDL distribution. If this file is
separated from the PDL distribution, the copyright notice should be
included in the file.

';

########################################################3

# if no bad-value support, this is easy

unless ( $bvalflag ) {

    pp_addpm({At=>'Top'},<<"!WITH!SUBS!");

=head1 NAME

PDL::Bad - PDL does not process bad values

=head1 DESCRIPTION

PDL has been compiled with WITH_BADVAL either 0 or undef,
so it does not contain any bad-value support code.

=head1 SYNOPSIS

none

$author

=head1 BUGS

None.

=cut

# do nothing

!WITH!SUBS!

    pp_export_nothing();
    pp_done();
    exit;

} # unless: $bvalflag

########################################################3

pp_add_exported( '', 'baddata badvalue orig_badvalue' );

pp_addpm({At=>'Top'},<<'!NO!SUBS!');

=head1 NAME

PDL::Bad - PDL does process bad values

=head1 DESCRIPTION

PDL has been compiled with WITH_BADVAL set to 1. Therefore,
you can enter the wonderful world of bad values.

=head1 SYNOPSIS

Errrr

=cut

use strict;

use PDL::Types;
use PDL::Primitive;

############################################################
############################################################
##							    
## XXX BADVAL XXX					    
##							    
## these are left over from a previous attempt. 	    
## need re-doing - or at least thinking about		    
##							    
############################################################
############################################################

!NO!SUBS!

pp_addxs( "#define setflag(reg,flagval,val) (val?(reg |= flagval):(reg &= ~flagval))\n" );

my %flags = 
    ( 
      baddata => { set => 1, FLAG => "BADVAL" },
      );

# we want the following to be in PDL, not PDL::Bad, hence
my $xshdr = "MODULE = PDL::Bad PACKAGE = PDL";

foreach my $name ( keys %flags ) {
    my $flag = "PDL_" . ($flags{$name}{FLAG} || uc($name));
    if ( $flags{$name}{set} ) {
	pp_addxs( <<"!WITH!SUBS!");
$xshdr

int
$name(x,mode=0)
	pdl *x
	int mode
	CODE:
	if (items>1) 
	   { setflag(x->state,$flag,mode); }
	RETVAL = ((x->state & $flag) > 0);
	OUTPUT:
	RETVAL

!WITH!SUBS!

} else {
	pp_addxs( <<"!WITH!SUBS!");
$xshdr

int
$name(self)
	pdl *self
	CODE:
	RETVAL = ((self->state & $flag) > 0);
	OUTPUT:
	RETVAL

!WITH!SUBS!

} # if: $flags{name}{set}

} # foreach: keys %flags 

pp_addpm(<<'!NO!SUBS!');
############################################################
############################################################

*baddata       = \&PDL::baddata;
*badvalue      = \&PDL::badvalue;
*orig_badvalue = \&PDL::badvalue;

############################################################
############################################################

=head2 baddata

=for ref

switch on/off/examine bad data flag

=for example

  if ( $a->baddata() ) { 
    print "Data may contain bad values.\n"; 
  }
  $a->baddata(1);      # set bad data flag
  $a /= $b;            # b may contain zeroes
  $a->baddata(0);      # unset bad data flag

Bibble.

=cut

############################################################
############################################################

=head2 badvalue

=for ref

returns the value used to indicate a missing (or bad) element
for the given piddle type. You can give it a piddle, 
a L<PDL::Type> object, or one of C<$PDL_B>, C<$PDL_S>, etc.

=for example

   $badval = badvalue( float );
   $a = ones(ushort,10);
   print "The bad data value for ushort is: ", 
      $a->badvalue(), "\n";

TODO: when called via a piddle - eg C<$pdl->badvalue(23)> -
then it should change not only the default bad value for that type, but
change the value stored in the piddle as well.

=cut

=head2 orig_badvalue

=for ref

returns the original value used to represent bad values for
a given type.

This routine operates the same as L<badvalue|/badvalue>, 
except you can not change the values.

=for example

   $orig_badval = orig_badvalue( float );
   $a = ones(ushort,10);
   print "The original bad data value for ushort is: ", 
      $a->orig_badvalue(), "\n";

=cut

!NO!SUBS!

use PDL::Types;
my $ntypes = $#PDL::Types::names;

my $cases = "    switch ( type ) {\n";
my $default_cases = "    switch ( type ) {\n";

foreach my $i ( 0 .. $ntypes ) {
    my $type = new PDL::Type $i;
    my $ctype = $type->ctype;
    
    my $storage = "PDL->bvals._$ctype";

    $cases .= 
"  case $i:
     if ( items > 1 ) { $storage = (".$type->realctype().") val; }
     RETVAL = $storage;
   break;
";

    $default_cases .= 
"  case $i:
     RETVAL = PDL->bvals.default_$ctype;
   break;
";
}

$cases .= "  default:\n    barf(\"badvalue: type must be between 0 and $ntypes inclusive.\");    } /* end of switch */\n";
$default_cases .= "  default:\n    barf(\"badvalue: type must be between 0 and $ntypes inclusive.\");    } /* end of switch */\n";

pp_addxs( <<"!WITH!SUBS!");
$xshdr

double
_badvalue_int(type,val=0)
    int type
    double val
  CODE:
$cases
  OUTPUT:
    RETVAL

double
_default_badvalue_int(type)
    int type
  CODE:
$default_cases
  OUTPUT:
    RETVAL

!WITH!SUBS!

pp_addpm(<<'!NO!SUBS!');

# add a new method to PDL::Type
{
    package PDL::Type;
    sub badvalue { 
	my ( $self, $val ) = @_;
	if ( defined $val ) {
	    return PDL::_badvalue_int( $self->enum, $val );
	} else {
	    return PDL::_badvalue_int( $self->enum );
	}
    }

    sub orig_badvalue { 
	my $self = shift;
	return PDL::_default_badvalue_int( $self->enum );
    }
}
	    
sub PDL::badvalue {
    my ( $self, $val ) = @_;
    my $num;
    if ( UNIVERSAL::isa($self,"PDL") ) {
	$num = $self->get_datatype;
    } elsif ( UNIVERSAL::isa($self,"PDL::Type") ) {
	$num = $self->enum;
    } else {
        # assume it's a number
        $num = $self;
    }
    if ( defined $val ) {
	return PDL::_badvalue_int( $num, $val );
    } else {
	return PDL::_badvalue_int( $num );
    }
} # sub: badvalue()

sub PDL::orig_badvalue {
    my $self = shift;
    my $num;
    if ( UNIVERSAL::isa($self,"PDL") ) {
	$num = $self->get_datatype;
    } elsif ( UNIVERSAL::isa($self,"PDL::Type") ) {
	$num = $self->enum;
    } else {
        # assume it's a number
        $num = $self;
    }
    return PDL::_default_badvalue_int( $num );

} # sub: orig_badvalue()

############################################################
############################################################

!NO!SUBS!

sub isdocs {
    my $name = shift;
    my $out  = shift;

    return "

=for ref

Is a value $name?

Returns a 1 if the value is $name, 0 otherwise.

=for example

 \$a = pdl(1,2,3);
 \$a->baddata(1);
 set(\$a,1,\$a->badvalue);
 \$b = is$name(\$a);
 print \$b, \"\\n\";
 $out (I hope)

";
} # isdocs()

pp_def(
       'isbad',
       HandleBad => 1,
       Pars => 'a(); int [o]b();',
       Code => 
       '$b() = 0;',
       BadCode => 
       '$b() = $a() == a_badval;',
       CopyBadStatusCode => '',
       Doc => isdocs("bad","[0 1 0]"),
       );

pp_def(
       'isgood',
       HandleBad => 1,
       Pars => 'a(); int [o]b();',
       Code => 
       '$b() = 0;',
       BadCode => 
       '$b() = $a() != a_badval;',
       CopyBadStatusCode => '',
       Doc => isdocs("good","[1 0 1]"),
       );


# modified from primitive.pd
#
sub projectdocs {
    my $name = shift;
    my $op = shift;
    return <<EOD;

=for ref

Find the number of $name elements along the 1st dimension.

This function reduces the dimensionality of a piddle
by one by finding the number of $name elements
along the 1st dimension.

By using L<xchg|PDL::Slices/xchg> etc. it is possible to use
I<any> dimension.

=for usage

 \$a = $op(\$b);

=for example

 \$spectrum = $op \$image->xchg(0,1)

=cut

EOD

} # sub: projectdocs()

# see tests 23 and 24 in t/bad.t
# - WHY DO THEY FAIL?
#   and is it machine specific 
#   (ie fail on linux, succeed on solaris)
#   - needs checking
pp_def(
       'nbadover',
       HandleBad => 1,
       Pars => 'a(n); int+ [o]b();',
       Code => 
       '$b() = 0;',
       BadCode => 
       '$GENERIC(b) cnt = 0;
	loop(n) %{ 
           if ( $a() == a_badval ) { cnt++; }
        %}
        $b() = cnt;',
       Doc => projectdocs('bad','nbadover'),
       );

pp_def(
       'ngoodover',
       HandleBad => 1,
       Pars => 'a(n); int+ [o]b();',
       Code => 
       '$b() = ($GENERIC(b)) $SIZE(n);',
       BadCode => 
       '$GENERIC(b) cnt = 0;
	loop(n) %{ 
           if ( $a() != a_badval ) { cnt++; }
        %}
        $b() = cnt;',
       Doc => projectdocs('good','ngoodover'),
       );


# Generate small ops functions to do entire array

foreach my $op ( 
	  ['nbad','nbadover','bad'],
	  ['ngood','ngoodover','good'],
	  ) {
    pp_add_exported('', $op->[0]);

    pp_addpm(<<"EOD");

=head2 $op->[0]

=for ref

Returns the number of $op->[2] values in a piddle

=for usage

 \$x = $op->[0](\$data);

=cut

*$op->[0] = \\&PDL::$op->[0];
sub PDL::$op->[0] {
	my(\$x) = \@_; my \$tmp;
	\$x->clump(-1)->$op->[1](\$tmp=PDL->nullcreate(\$x) );
	return \$tmp->at();
}
EOD

} # for $op

pp_addpm({At=>'Bot'},<<"!WITH!SUBS!");

$author

=head1 BUGS

Loads, I'm sure.

=cut

!WITH!SUBS!

pp_done;
