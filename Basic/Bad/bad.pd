# 
# The contents of Bad.pm depend on whether we have
# bad-value support in PDL.
#

use strict;

# check for bad value support
use PDL::Config;
my $bvalflag = $PDL::Config{WITH_BADVAL} || 0;

########################################################3

my $author = '

=head1 AUTHOR

Doug Burke (burke@ifa.hawaii.edu) and ...

All rights reserved. There is no warranty. You are allowed to
redistribute this software / documentation under certain conditions. For
details, see the file COPYING in the PDL distribution. If this file is
separated from the PDL distribution, the copyright notice should be
included in the file.

';

########################################################3

# if no bad-value support, this is easy

unless ( $bvalflag ) {

    pp_addpm({At=>'Top'},<<"!WITH!SUBS!");

=head1 NAME

PDL::Bad - PDL does not process bad values

=head1 DESCRIPTION

PDL has been compiled with WITH_BADVAL either 0 or undef,
so it does not contain any bad-value support code.

=head1 SYNOPSIS

 use PDL::Bad;
 print "\nBad value support in PDL is turned " . 
     $PDL::Bad::Status ? "on" : "off" . ".\n";

 Bad value support in PDL is turned off.

$author

=head1 BUGS

None - it does nothing perfectly!

=cut

# really should be a constant
$PDL::Bad::Support = 0;

!WITH!SUBS!

    pp_export_nothing();
    pp_done();
    exit;

} # unless: $bvalflag

#########################################################

pp_add_exported( '', 'badflag badvalue orig_badvalue badvalue_as_pdl' );

## Header
pp_addpm({At=>'Top'},<<'!NO!SUBS!');

=head1 NAME

PDL::Bad - PDL does process bad values

=head1 DESCRIPTION

PDL has been compiled with WITH_BADVAL set to 1. Therefore,
you can enter the wonderful world of bad values.

This module is loaded when you do C<use PDL>, 
C<Use PDL::Lite> or C<PDL::LiteF>.

=head1 SYNOPSIS

 use PDL::Bad;
 print "\nBad value support in PDL is turned " . 
     $PDL::Bad::Status ? "on" : "off" . ".\n";

 Bad value support in PDL is turned on.

 and some other things

=cut

# really should be a constant
$PDL::Bad::Status = 1;

use strict;

use PDL::Types;
use PDL::Primitive;

############################################################
############################################################

!NO!SUBS!

## Footer
pp_addpm({At=>'Bot'},<<"!WITH!SUBS!");

$author

=head1 BUGS

Loads, I'm sure.

=cut

!WITH!SUBS!

    pp_addhdr( <<'!NO!SUBS!');

/* newval = 1 means set flag, 0 means clear it */
/* thanks to Christian Soeller for this */

void propogate_badflag( pdl *it, int newval ) {
    PDL_DECL_CHILDLOOP(it)
    PDL_START_CHILDLOOP(it)

    {
	pdl_trans *trans = PDL_CHILDLOOP_THISCHILD(it);
	int i;

	for( i = trans->vtable->nparents;
	     i < trans->vtable->npdls;
	     i++ ) {
	    
	    pdl *child = trans->pdls[i];

/* for my dbg purposes */
if ( child == it ) barf("ERROR in propogate_badflag (Basic/Bad/bad.pd): child == parent.\n");

	    if ( newval ) child->state |=  PDL_BADVAL;
            else          child->state &= ~PDL_BADVAL;

	    /* make sure we propogate to grandchildren, etc */
	    propogate_badflag( child, newval );

        } /* for: i */

    }

    PDL_END_CHILDLOOP(it)

} /* propogate_badflag */

!NO!SUBS!

# we want the following to be in PDL, not PDL::Bad, hence
my $xshdr = "MODULE = PDL::Bad PACKAGE = PDL";

# 
# we want badflag() to avoid unnecessary calls to propogate_badflag(), 
# since it has to recurse through all the children of a piddle
#

pp_addxs( <<"!WITH!SUBS!");
$xshdr

int
badflag(x,newval=0)
    pdl *x
    int newval
  CODE:
    if (items>1) { 
	int oldval = ((x->state & PDL_BADVAL) > 0);
        if ( !newval && oldval ) { 
	    /* asked to unset, present value is set */
	    x->state &= ~PDL_BADVAL;
            propogate_badflag( x, 0 );
        } else if ( newval && !oldval ) {
	    /* asked to set, present value is unset */
	    x->state |= PDL_BADVAL;
            propogate_badflag( x, 1 );
	}
    }
    RETVAL = ((x->state & PDL_BADVAL) > 0);
  OUTPUT:
    RETVAL

!WITH!SUBS!

pp_addpm(<<'!NO!SUBS!');
############################################################
############################################################

*badflag         = \&PDL::badflag;
*badvalue        = \&PDL::badvalue;
*orig_badvalue   = \&PDL::orig_badvalue;

############################################################
############################################################

=head2 badflag

=for ref

switch on/off/examine bad data flag

=for example

  if ( $a->badflag() ) { 
    print "Data may contain bad values.\n"; 
  }
  $a->badflag(1);      # set bad data flag
  $a /= $b;            # b may contain zeroes
  $a->badflag(0);      # unset bad data flag

A return value of 1 does not guarantee the presence of
bad data in a piddle; all it does is say that we need to 
I<check> for the presence of such beasties. To actually 
find out if there are any bad values, use the 
L<nbad|nbad> method (after ensuring that C<badflag>
is set!).

=for bad

Does support bad values.

=head2 badvalue

=for ref

returns the value used to indicate a missing (or bad) element
for the given piddle type. You can give it a piddle, 
a PDL::Type object, or one of C<$PDL_B>, C<$PDL_S>, etc.

=for example

   $badval = badvalue( float );
   $a = ones(ushort,10);
   print "The bad data value for ushort is: ", 
      $a->badvalue(), "\n";

TODO: when called via a piddle - eg C<$pdl-E<gt>badvalue(23)> -
then it should change not only the default bad value for that type, but
also change the value stored in the piddle as well.

=for bad

Does support bad values.

=head2 orig_badvalue

=for ref

returns the original value used to represent bad values for
a given type.

This routine operates the same as L<badvalue|/badvalue>, 
except you can not change the values.

It is also has an awful name.

=for example

   $orig_badval = orig_badvalue( float );
   $a = ones(ushort,10);
   print "The original bad data value for ushort is: ", 
      $a->orig_badvalue(), "\n";

=for bad

Does support bad values.

=head2 check_badstatus

=for ref

clear the bad-value flag of a piddle if it does not
contain any bad values

Given a piddle whose bad flag is set, check whether it 
actually contains any bad values and, if not, clear the flag.
It returns the final state of the bad-value flag.

=for example

 print "State of bad flag == ", $pdl->check_badstatus;

=for bad

Does support bad values.

=cut

*check_badstatus = \&PDL::check_badstatus;

sub PDL::check_badstatus {
    my $pdl = shift;
    $pdl->badflag(0) if $pdl->badflag and $pdl->nbad == 0;
    return $pdl->badflag;
} # sub: check_badstatus()

!NO!SUBS!

use PDL::Types;
my $ntypes = $#PDL::Types::names;

    my $str;
foreach my $i ( 0 .. $ntypes ) {
    my $type = new PDL::Type $i;
    my $ctype = $type->ctype;
    my $realctype = $type->realctype;
    my $storage = "PDL->bvals._$ctype";

    $str .= 
"
$realctype
_badvalue_int${i}(val=0)
    double val
  CODE:
    if ( items > 0 ) { $storage = ($realctype) val; }
    RETVAL = $storage;
  OUTPUT:
    RETVAL
    
$realctype
_default_badvalue_int${i}()
  CODE:
    RETVAL = PDL->bvals.default_$ctype;
  OUTPUT:
    RETVAL
    
";

} # foreach: $i = 0 .. $ntypes

pp_addxs( "\n$xshdr\n\n$str\n" );

pp_addpm(<<'!NO!SUBS!');

# add a new method to PDL::Type
{
    package PDL::Type;

    no strict 'refs';
    sub badvalue { 
	my ( $self, $val ) = @_;
	my $name = "PDL::_badvalue_int" . $self->enum();
	if ( defined $val ) {
	    return &{$name}( $val );
	} else {
	    return &{$name}();
	}
    }

    sub orig_badvalue { 
	my $self = shift;
	my $name = "PDL::_default_badvalue_int" . $self->enum();
	return &{$name}();
    }

} # end of package PDL::Type
	    
sub PDL::badvalue {
    no strict 'refs';

    my ( $self, $val ) = @_;
    my $num;
    if ( UNIVERSAL::isa($self,"PDL") ) {
	$num = $self->get_datatype;
    } elsif ( UNIVERSAL::isa($self,"PDL::Type") ) {
	$num = $self->enum;
    } else {
        # assume it's a number
        $num = $self;
    }

    my $name = "PDL::_badvalue_int$num";
    if ( defined $val ) {
	return &{$name}( $val );
    } else {
	return &{$name}();
    }

} # sub: badvalue()

sub PDL::orig_badvalue {
    no strict 'refs';

    my $self = shift;
    my $num;
    if ( UNIVERSAL::isa($self,"PDL") ) {
	$num = $self->get_datatype;
    } elsif ( UNIVERSAL::isa($self,"PDL::Type") ) {
	$num = $self->enum;
    } else {
        # assume it's a number
        $num = $self;
    }

    my $name = "PDL::_default_badvalue_int$num";
    return &${name}();

} # sub: orig_badvalue()

############################################################
############################################################

!NO!SUBS!

sub isdocs {
    my $name = shift;
    my $out  = shift;

    return "

=for ref

Is a value $name?

Returns a 1 if the value is $name, 0 otherwise.

=for example

 \$a = pdl(1,2,3);
 \$a->badflag(1);
 set(\$a,1,\$a->badvalue);
 \$b = is$name(\$a);
 print \$b, \"\\n\";
 $out

";
} # isdocs()

pp_def(
       'isbad',
       HandleBad => 1,
       Pars => 'a(); int [o]b();',
       Code => 
       '$b() = 0;',
       BadCode => 
       '$b() = $ISBAD(a());',
       CopyBadStatusCode => '',
       Doc => isdocs("bad","[0 1 0]"),
       );

pp_def(
       'isgood',
       HandleBad => 1,
       Pars => 'a(); int [o]b();',
       Code => 
       '$b() = 0;',
       BadCode => 
       '$b() = $ISGOOD(a());',
       CopyBadStatusCode => '',
       Doc => isdocs("good","[1 0 1]"),
       );


# modified from primitive.pd
#
sub projectdocs {
    my $name = shift;
    my $op = shift;
    return <<EOD;

=for ref

Find the number of $name elements along the 1st dimension.

This function reduces the dimensionality of a piddle
by one by finding the number of $name elements
along the 1st dimension.

By using L<xchg|PDL::Slices/xchg> etc. it is possible to use
I<any> dimension.

=for usage

 \$a = $op(\$b);

=for example

 \$spectrum = $op \$image->xchg(0,1)

=cut

EOD

} # sub: projectdocs()

# perhaps these should have pm code which returns the
# answer if the bad flag is not set
pp_def(
       'nbadover',
       HandleBad => 1,
       Pars => 'a(n); int+ [o]b();',
       Code => 
       '$b() = 0;',
       BadCode => 
       '$GENERIC(b) cnt = 0;
	loop(n) %{ 
           if ( $ISBAD(a()) ) { cnt++; }
        %}
        $b() = cnt;',
       Doc => projectdocs('bad','nbadover'),
       );

pp_def(
       'ngoodover',
       HandleBad => 1,
       Pars => 'a(n); int+ [o]b();',
       Code => 
       '$b() = ($GENERIC(b)) $SIZE(n);',
       BadCode => 
       '$GENERIC(b) cnt = 0;
	loop(n) %{ 
           if ( $ISGOOD(a()) ) { cnt++; }
        %}
        $b() = cnt;',
       Doc => projectdocs('good','ngoodover'),
       );


# Generate small ops functions to do entire array

foreach my $op ( 
	  ['nbad','nbadover','bad'],
	  ['ngood','ngoodover','good'],
	  ) {
    pp_add_exported('', $op->[0]);

    pp_addpm(<<"EOD");

=head2 $op->[0]

=for ref

Returns the number of $op->[2] values in a piddle

=for usage

 \$x = $op->[0](\$data);

=for bad

Does support bad values.

=cut

*$op->[0] = \\&PDL::$op->[0];
sub PDL::$op->[0] {
	my(\$x) = \@_; my \$tmp;
	\$x->clump(-1)->$op->[1](\$tmp=PDL->nullcreate(\$x) );
	return \$tmp->at();
}
EOD

} # for $op

# NOTE: the Code section uses SETBAD 
#
# something strange is going in with inplace here...
#

pp_def(
    'setbadif',
    HandleBad => 1,
    Pars => 'a(); mask(); [o]b();',
    Inplace => [ 'a', 'b' ],
    Code =>
    'if ( $mask() ) {
        $SETBAD(b());
     } else {
        $b() = $a();
     }',
    BadCode =>
    'if ( $ISBAD(mask()) || $mask() ) {   /* in case the bad value == 0 */
        $SETBAD(b());
     } else {
        $b() = $a();
     }',
    CopyBadStatusCode => 
#    '$SETPDLSTATEBAD(b);',  # always make sure the output is "bad"
# use the following if finally get it working inplace
    'if ( a == b && $ISPDLSTATEGOOD(a) )
       propogate_badflag( b, 1 ); /* propogate badflag if inplace */
     $SETPDLSTATEBAD(b);          /* always make sure the output is "bad" */
    ',
    Doc => 
'
=for ref

Set elements bad based on the supplied mask, otherwise
copy across the data.

=for example

 $a = sequence(5,5);
 $a = $a->setbadif( $a % 2 );
 print "a badflag: ", $a->badflag, "\n";
 a badflag: 1

This should *NOT* be used inplace (currently rather broken).

',
       BadDoc =>
'The output always has its bad flag set, even if it does not contain
any bad values. Any bad values in the input piddles are copied
across to the output piddle.
',
       ); # pp_def: setbadif

pp_def(
    'replacebad',
    HandleBad => 1,
    Pars => 'a(); [o]b();',
    OtherPars => 'double newval',
    Inplace => [ 'a', 'b' ],
    Code => '$b() = $a();',
    BadCode => 
    '$GENERIC(b) replace = ($GENERIC(b)) $COMP(newval);
     threadloop %{
        if ( $ISBAD(a()) ) {
           $b() = replace;
        } else {
           $b() = $a();
        }
     %}',
    CopyBadStatusCode => 
    'if ( a == b && $ISPDLSTATEBAD(a) )
       propogate_badflag( b, 0 );  /* propogate badflag if inplace AND its changed */
     $SETPDLSTATEGOOD(b);          /* always make sure the output is "good" */
    ',
    Doc => 
'
=for ref

Replace any bad values by a (non-bad) value. 

Can be done inplace.

=for example

 $a->inplace->replacebad(23); 
 print "a badflag: ", $a->badflag, "\n";
 a badflag: 0

',
       BadDoc =>
'The output always has its bad flag cleared.
If the input piddle does not have its bad flag set, then
values are copied with no replacement.
',
       ); # pp_def: replacebad

pp_def(
    'copybad',
    HandleBad => 1,
    Pars => 'a(); mask(); [o]b();',
    Inplace => [ 'a', 'b' ],
    Code =>
    '$b() = $a();',
    BadCode =>
    'if ( $ISBAD(mask()) ) {
        $SETBAD(b());
     } else {
        $b() = $a();
     }',
    CopyBadStatusCode =>
    'if ( __privtrans->bvalflag ) {
        if ( a == b && $ISPDLSTATEGOOD(a) ) {
           propogate_badflag( b, 1 ); /* have inplace op AND badflag has changed */
        }
        $SETPDLSTATEBAD(b);
     }',
    Doc => 
'
=for ref

Copies values from one piddle to another, setting them
bad if they are bad in the supplied mask.

Can be done inplace.

=for example

 $a = byte( [0,1,3] );
 $mask = byte( [0,0,0] );
 set($mask,1,$mask->badvalue);
 $a->inplace->copybad( $mask );
 p $a;
 [0 BAD 3]

It is equivalent to:

 $c = $a + $mask * 0

',
    BadDoc =>
'Handles bad values.',

    ); # pp_def: copybad

pp_done;
