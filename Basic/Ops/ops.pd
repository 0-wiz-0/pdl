pp_addpm({At=>Top},<<'EOD');

=head1 NAME

PDL::Ops - Fundamental mathematical operators

=head1 DESCRIPTION

This module provides the functions used by PDL to
overload the basic mathematical operators (C<+ - / *>
etc.) and functions (C<sin sqrt> etc.)

=head1 SYNOPSIS

none

=cut

EOD
pp_addhdr('
#include <math.h>

#define MOD(X,N)     ( (X) - (N)*((int)((X)/(N))) )
#define SPACE(A,B)   ( ((A)<(B)) ? -1 : ((A)!=(B)) )
#define ABS(A)       ( (A)>=0 ? (A) : -(A) )
#define NOTHING
');

my $pars1 = 'a(); b(); [o]c();';
my $pars2 = 'a(); [o]b()';

# bifuncs
pp_def ('plus',       Pars => $pars1, OtherPars => 'int swap', Code => '$c() = $a() + $b();');
pp_def ('multiply',   Pars => $pars1, OtherPars => 'int swap', Code => '$c() = $a() * $b();');

pp_def ('minus',      Pars => $pars1, OtherPars => 'int swap', Code => 'if ($COMP(swap)) $c() = $b() - $a(); else $c() = $a() - $b();');
pp_def ('divide',     Pars => $pars1, OtherPars => 'int swap', Code => 'if ($COMP(swap)) $c() = $b() / $a(); else $c() = $a() / $b();');

pp_def ('gt',         Pars => $pars1, OtherPars => 'int swap', Code => 'if ($COMP(swap)) $c() = $b() >  $a(); else $c() = $a() >  $b();');
pp_def ('lt',         Pars => $pars1, OtherPars => 'int swap', Code => 'if ($COMP(swap)) $c() = $b() <  $a(); else $c() = $a() <  $b();');
pp_def ('le',         Pars => $pars1, OtherPars => 'int swap', Code => 'if ($COMP(swap)) $c() = $b() <= $a(); else $c() = $a() <= $b();');
pp_def ('ge',         Pars => $pars1, OtherPars => 'int swap', Code => 'if ($COMP(swap)) $c() = $b() >= $a(); else $c() = $a() >= $b();');

pp_def ('eq',         Pars => $pars1, OtherPars => 'int swap', Code => '$c() = $b() == $a();');
pp_def ('ne',         Pars => $pars1, OtherPars => 'int swap', Code => '$c() = $b() != $a();');

pp_def ('shiftleft',  Pars => $pars1, OtherPars => 'int swap', 
	GenericTypes => [B,U,S,L], Code => 'if ($COMP(swap)) $c() = $b() << $a(); else $c() = $a() << $b();');
pp_def ('shiftright', Pars => $pars1, OtherPars => 'int swap', 
	GenericTypes => [B,U,S,L], Code => 'if ($COMP(swap)) $c() = $b() >> $a(); else $c() = $a() >> $b();');

pp_def ('orop',       Pars => $pars1, OtherPars => 'int swap', GenericTypes => [B,U,S,L], Code => '$c() = $b() | $a();');
pp_def ('andop',      Pars => $pars1, OtherPars => 'int swap', GenericTypes => [B,U,S,L], Code => '$c() = $b() & $a();');
pp_def ('xor',        Pars => $pars1, OtherPars => 'int swap', GenericTypes => [B,U,S,L], Code => '$c() = $b() ^ $a();');
pp_def ('bitnot',     Pars => $pars2, OtherPars => 'int swap', GenericTypes => [B,U,S,L], Code => '$b() = ~$a();');


pp_def ('power',      Pars => $pars1, OtherPars => 'int swap', 
	GenericTypes => [D], Code => 'if ($COMP(swap)) $c() = pow($b(),$a());   else $c() = pow($a(),$b());');
pp_def ('atan2',      Pars => $pars1, OtherPars => 'int swap', 
	GenericTypes => [D], Code => 'if ($COMP(swap)) $c() = atan2($b(),$a()); else $c() = atan2($a(),$b());');
pp_def ('modulo',     Pars => $pars1, OtherPars => 'int swap', Code => 'if ($COMP(swap)) $c() = MOD($b(),$a());   else $c() = MOD($a(),$b());');
pp_def ('spaceship',  Pars => $pars1, OtherPars => 'int swap', Code => 'if ($COMP(swap)) $c() = SPACE($b(),$a()); else $c() = SPACE($a(),$b());');

# ufuncs

pp_def ('sqrt',       Pars => $pars2, Code => '$b() = sqrt($a());');
pp_def ('abs',        Pars => $pars2, GenericTypes => [D,F,S,L],Code => '$b() = ABS ($a());');
pp_def ('sin',        Pars => $pars2, Code => '$b() = sin ($a());');
pp_def ('cos',        Pars => $pars2, Code => '$b() = cos ($a());');

pp_def ('not',        Pars => $pars2, Code => '$b() = !$a();');

pp_def ('log',        Pars => $pars2, GenericTypes => [D], Code => '$b() = log($a());');
pp_def ('exp',        Pars => $pars2, GenericTypes => [D], Code => '$b() = exp($a());');

pp_addpm({At=>Bot},<<'EOPM');

=head1 AUTHOR

Doug Hunt (dhunt@ucar.edu), Tuomas J. Lukka (lukka@fas.harvard.edu) and Karl Glazebrook
(kgb@aaoepp.aao.gov.au).

=cut

EOPM

pp_export_nothing(); 
pp_done();

