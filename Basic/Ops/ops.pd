pp_addpm({At=>Top},<<'EOD');

=head1 NAME

PDL::Ops - Fundamental mathematical operators

=head1 DESCRIPTION

This module provides the functions used by PDL to
overload the basic mathematical operators (C<+ - / *>
etc.) and functions (C<sin sqrt> etc.)

=head1 SYNOPSIS

none

=cut

EOD
pp_addhdr('
#include <math.h>

#define MOD(X,N)     ( (X) - (N)*((int)((X)/(N))) )
#define SPACE(A,B)   ( ((A)<(B)) ? -1 : ((A)!=(B)) )
#define ABS(A)       ( (A)>=0 ? (A) : -(A) )
#define NOTHING
');

# simple binary operators

sub biop_bad {
	my ($name,$op,$swap,$doc,%extra) = @_;
	my $optxt = $op;
	if ($optxt =~ s/>/E<gt>/) {} else
	{ $optxt =~ s/</E<lt>/}
	if ($swap) {
	  $extra{HdrCode} = << 'EOH';
  pdl *tmp;
  if (swap) {
    tmp = a;
    a = b;
    b = tmp;
  }
EOH
        }
	# quick and dirty solution to get ->inplace do its job
	$extra{HdrCode} .= 'if (a->state & PDL_INPLACE)
				{
				  a->state &= ~PDL_INPLACE; /* unset */
				  c = a;  /* discard output value, leak? */
				}',
	pp_def($name,
	       Pars => 'a(); b(); [o]c();',
	       OtherPars => 'int swap',
	       HandleBad => 1,
	       Code => 
	       "\$c() = \$a() $op \$b();",
	       BadCode =>
	       'if ( $ISBAD($a()) || $ISBAD($b()) )
	          $SETBAD($c());
	        else' . "\n  \$c() = \$a() $op \$b();\n",
	       %extra,
	       Doc => << "EOD");
=for ref

$doc

=for example

   \$c = $name \$a, \$b, 0;     # explicit call with trailing 0
   \$c = \$a $op \$b;           # overloaded call
   \$a->inplace->$name(\$b,0);  # modify \$a inplace

It can be made to work inplace with the C<\$a-E<gt>inplace> syntax.
This function is used to overload the binary C<$optxt> operator.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
EOD
} # sub: biop_bad()

sub biop {
	my ($name,$op,$swap,$doc,%extra) = @_;
	my $optxt = $op;
	if ($optxt =~ s/>/E<gt>/) {} else
	{ $optxt =~ s/</E<lt>/}
	if ($swap) {
	  $extra{HdrCode} = << 'EOH';
  pdl *tmp;
  if (swap) {
    tmp = a;
    a = b;
    b = tmp;
  }
EOH
        }
	# quick and dirty solution to get ->inplace do its job
	$extra{HdrCode} .= 'if (a->state & PDL_INPLACE)
				{
				  a->state &= ~PDL_INPLACE; /* unset */
				  c = a;  /* discard output value, leak? */
				}',
	pp_def($name,
		Pars => 'a(); b(); [o]c();',
		OtherPars => 'int swap',
		Code => "\$c() = \$a() $op \$b();",
		%extra,
		Doc => << "EOD");
=for ref

$doc

=for example

   \$c = $name \$a, \$b, 0;     # explicit call with trailing 0
   \$c = \$a $op \$b;           # overloaded call
   \$a->inplace->$name(\$b,0);  # modify \$a inplace

It can be made to work inplace with the C<\$a-E<gt>inplace> syntax.
This function is used to overload the binary C<$optxt> operator.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
EOD
} # sub: biop()

#simple binary functions
sub bifunc_bad {
	my ($name,$func,$swap,$doc,%extra) = @_;
	if ($swap) {
	  $extra{HdrCode} .= << 'EOH';
  pdl *tmp;
  if (swap) {
    tmp = a;
    a = b;
    b = tmp;
  }
EOH
        }
	# quick and dirty solution to get ->inplace do its job
	$extra{HdrCode} .= 'if (a->state & PDL_INPLACE)
				{
				  a->state &= ~PDL_INPLACE; /* unset */
				  c = a;  /* discard output value, leak? */
				}';
	pp_def($name,
	       HandleBad => 1,
	       Pars => 'a(); b(); [o]c();',
	       OtherPars => 'int swap',
	       Code => 
	       "\$c() = $func(\$a(),\$b());",
	       BadCode =>
	       'if ( $ISBAD(a()) || $ISBAD(b()) )
	          $SETBAD(c());
	        else' . "\n  \$c() = $func(\$a(),\$b());\n",
	       %extra,
	       Doc => << "EOD");
=for ref

$doc

=for example

   \$c = \$a->$name(\$b,0); # explicit function call
   \$c = $name \$a, \$b;    # overloaded use
   \$a->inplace(\$b,0);     # modify \$a inplace

It can be made to work inplace with the C<\$a-E<gt>inplace> syntax.
This function is used to overload the binary C<$func> function.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
EOD
} # sub: bifunc_bad()

#simple binary functions
sub bifunc {
	my ($name,$func,$swap,$doc,%extra) = @_;
	if ($swap) {
	  $extra{HdrCode} .= << 'EOH';
  pdl *tmp;
  if (swap) {
    tmp = a;
    a = b;
    b = tmp;
  }
EOH
        }
	# quick and dirty solution to get ->inplace do its job
	$extra{HdrCode} .= 'if (a->state & PDL_INPLACE)
				{
				  a->state &= ~PDL_INPLACE; /* unset */
				  c = a;  /* discard output value, leak? */
				}';
	pp_def($name,
		Pars => 'a(); b(); [o]c();',
		OtherPars => 'int swap',
		Code => "\$c() = $func(\$a(),\$b());",
		%extra,
		Doc => << "EOD");
=for ref

$doc

=for example

   \$c = \$a->$name(\$b,0); # explicit function call
   \$c = $name \$a, \$b;    # overloaded use
   \$a->inplace(\$b,0);     # modify \$a inplace

It can be made to work inplace with the C<\$a-E<gt>inplace> syntax.
This function is used to overload the binary C<$func> function.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
EOD
} # sub: bifunc()

# simple unary functions and operators
sub ufunc_bad {
	my ($name,$func,$doc,%extra) = @_;
	pp_def($name,
	       Pars => 'a(); [o]b()',
	       HandleBad => 1,
	       Code => 
	       "\$b() = $func(\$a());",
	       BadCode =>
	       'if ( $ISBAD($a()) )
	          $SETBAD($b());
	       else' . "\n  \$b() = $func(\$a());\n",
	       HdrCode => 'if (a->state & PDL_INPLACE)
				{
				  a->state &= ~PDL_INPLACE; /* unset */
				  b = a;  /* discard output value, leak? */
				}',
	       %extra,
	       Doc => << "EOD");
=for ref

$doc

=for example

   \$b = $func \$a;
   \$a->inplace->$func;  # modify \$a inplace

It can be made to work inplace with the C<\$a-E<gt>inplace> syntax.
This function is used to overload the unary C<$func> operator/function.
EOD
} # sub: ufunc_bad()

sub ufunc {
	my ($name,$func,$doc,%extra) = @_;
	pp_def($name,
		Pars => 'a(); [o]b()',
		Code => "\$b() = $func(\$a());",
		HdrCode => 'if (a->state & PDL_INPLACE)
				{
				  a->state &= ~PDL_INPLACE; /* unset */
				  b = a;  /* discard output value, leak? */
				}',
		%extra,
		Doc => << "EOD");
=for ref

$doc

=for example

   \$b = $func \$a;
   \$a->inplace->$func;  # modify \$a inplace

It can be made to work inplace with the C<\$a-E<gt>inplace> syntax.
This function is used to overload the unary C<$func> operator/function.
EOD
} # sub: ufunc()

######################################################################

# it would make sense to trap illegal operations here (well, it would
# be nice if you could set up exceptions to catch them all, but it's
# not going to be portable)
#
# there is an issue over how we handle comparison operators
# - see Primitive/primitive.pd/zcover() for more discussion
#

## arithmetic ops
# no swap
biop_bad('plus','+',0,'add two piddles');
biop_bad('mult','*',0,'multiply two piddles');

# all those need swapping
biop_bad('minus','-',1,'subtract two piddles');
biop_bad('divide','/',1,'divide two piddles');
## note: divide should perhaps trap division by zero as well

## comparison ops
# need swapping
biop('gt','>',1,'the binary E<gt> (greater than) operation');
biop('lt','<',1,'the binary E<lt> (less than) operation');
biop('le','<=',1,'the binary E<lt>= (less equal) operation');
biop('ge','>=',1,'the binary E<gt>= (greater equal) operation');
# no swap required
biop('eq','==',0,'binary I<equal to> operation (==)');
biop('ne','!=',0,'binary I<not equal to> operation (!=)');

## bit ops
# those need to be limited to the right types
my $T = [B,U,S,L]; # the sensible types here
biop('shiftleft','<<',1,'leftshift C<a$> by C<$b>',GenericTypes => $T);
biop('shiftright','>>',1,'leftshift C<a$> by C<$b>',GenericTypes => $T);
biop('or2','|',0,'binary I<or> of two piddles',GenericTypes => $T);
biop('and2','&',0,'binary I<and> of two piddles',GenericTypes => $T);
biop('xor','^',0,'binary I<exclusive or> of two piddles',GenericTypes => $T);

# really an ufunc
ufunc('bitnot','~','unary bit negation',GenericTypes => $T);

# some standard binary functions
bifunc_bad('power','pow',1,'raise piddle C<$a> to the power C<b>',GenericTypes => [D]);
bifunc_bad('atan2','atan2',1,'elementwise C<atan2> of two piddles',GenericTypes => [D]);
bifunc_bad('modulo','MOD',1,'elementwise C<modulo> operation');
bifunc_bad('spaceship','SPACE',1,'elementwise C<~> operation');

# some standard unary functions
ufunc('not','!','the elementwise I<not> operation');
ufunc_bad('sqrt','sqrt','elementwise square root');
ufunc_bad('abs','ABS','elementwise absolut value',GenericTypes => [D,F,S,L]);
ufunc_bad('sin','sin','the sin function');
ufunc_bad('cos','cos','the cos function');
ufunc_bad('log','log','the natural logarithm',GenericTypes => [D]);
ufunc_bad('exp','exp','the exponential function',GenericTypes => [D]);

pp_addpm({At=>Bot},<<'EOPM');

=head1 AUTHOR

Tuomas J. Lukka (lukka@fas.harvard.edu),
Karl Glazebrook (kgb@aaoepp.aao.gov.au), 
Doug Hunt (dhunt@ucar.edu), and 
Christian Soeller (c.soeller@auckland.ac.nz).

=cut

EOPM

pp_export_nothing(); 
pp_done();

