pp_addpm({At => 'Top'},<< 'EOD');

=head1 NAME

PDL::Slices -- Stupid index tricks

=head1 SYNOPSIS

  use PDL;
  $a = ones(3,3);
  $b = $a->slice('-1:0,(1)');
  $c = $a->dummy(2);


=head1 DESCRIPTION

This package provides many of the powerful PerlDL core index
manipulation routines. These routines are usually two-way
so you can get a unit matrix by

 $a = zeroes(1000,1000);
 $a->diagonal(0,1) ++;

which is usually fairly efficient. See L<PDL::Indexing> and
L<PDL::Tips> for more examples.

These functions are usually two-way:

 $b = $a->slice("1:3");
 $b += 5;   		# $a is changed!

If you want to force a copy and no "flow" backwards, you need

 $b = $a->slice("1:3")->copy;
 $b += 5;		# $a is not changed.

alternatively, you can use

 $b = $a->slice("1:3")->sever;

which does not copy the struct but beware that after

 $b = $a->slice("1:3");
 $c = $b->sever;

the variables C<$b> and C<$c> point to the same object but with 
C<-E<gt>copy> they do not.

The fact that there is this kind of flow makes PDL a very
powerful language in many ways: since you can alter the original
data by altering some easier-to-use representation of it, many things are
much easier to accomplish, just like making the above unit matrix.

Slicing is so central to the PDL language that a special compile-time
syntax has been introduced to handle it compactly; see L<PDL::NiceSlice> 
for details.

=head1 BUGS 

For the moment, you can't slice the empty piddle.  This should probably
change:  slices of the empty piddle should probably return the empty piddle.

Many types of index errors are reported far from the indexing
operation that caused them.  This is caused by the underlying architecture:
slice() sets up a mapping between variables, but that mapping isn't 
tested for correctness until it is used (potentially much later).

=cut

use PDL::Core ':Internal';

EOD

pp_addpm({At => 'Bot'},<< 'EOD');

=head1 AUTHOR

Copyright (C) 1997 Tuomas J. Lukka.  Contributions by
Craig DeForest, deforest@boulder.swri.edu.
All rights reserved. There is no warranty. You are allowed
to redistribute this software / documentation under certain
conditions. For details, see the file COPYING in the PDL
distribution. If this file is separated from the PDL distribution,
the copyright notice should be included in the file.

=cut

EOD

# $::PP_VERBOSE=1;

pp_add_boot(
"  PDL->readdata_affine = pdl_readdata_affineinternal;\n" . 
"     PDL->writebackdata_affine = pdl_writebackdata_affineinternal;\n"
);

## Several routines use the 'Dims' and 'ParentInds'
## rules - these currently do nothing

pp_def(
       'affineinternal',
       HandleBad => 1,
       AffinePriv => 1,
       DefaultFlow => 1,
       P2Child => 1,
       ReadDataFuncName => "pdl_readdata_affineinternal",
       WriteBackDataFuncName => "pdl_writebackdata_affineinternal",
       MakeComp => '$CROAK("AFMC MUSTNT BE CALLED");',
       RedoDims => '$CROAK("AFRD MUSTNT BE CALLED");',
       EquivCPOffsCode => '
		int i; int poffs=$PRIV(offs); int nd;
		for(i=0; i<$CHILD_P(nvals); i++) {
			$EQUIVCPOFFS(i,poffs);
			for(nd=0; nd<$CHILD_P(ndims); nd++) {
				poffs += $PRIV(incs[nd]);
				if(nd<$CHILD_P(ndims)-1 &&
				   (i+1)%$CHILD_P(dimincs[nd+1]) ||
				   nd == $CHILD_P(ndims)-1)
					break;
				poffs -= $PRIV(incs[nd]) *
					$CHILD_P(dims[nd]);
			}
                }',
       Doc => undef,    # 'internal',
);

pp_def(
	's_identity',
        HandleBad => 1,
	P2Child => 1,
	DefaultFlow => 1,
	OtherPars => '',
	Reversible => 1,
	Dims => '$COPYDIMS();',
	ParentInds => '$COPYINDS();',
	Identity => 1,
	Doc => 
'=for ref

Internal vaffine identity function.

=cut
',
);

$doc = <<'EOD';
=for ref

C<index> and C<index2d> provide rudimentary index indirection.

=for example

 $c = index($source,$ind);
 $c = index2d($source2,$ind1,$ind2);

use the C<$ind> variables as indices to look up values in C<$source>.  
C<index2d> uses separate piddles for X and Y coordinates.  For more
general N-dimensional indexing, see L<PDL::Slices> or the L<PDL::NiceSlice>
syntax.

These functions are two-way, i.e. after

 $c = $a->index(pdl[0,5,8]);
 $c .= pdl [0,2,4];

the changes in C<$c> will flow back to C<$a>.

C<index> provids simple threading:  multiple-dimensioned arrays are treated
as collections of 1-D arrays, so that

 $a = xvals(10,10)+10*yvals(10,10);
 $b = $a->index(3);
 $c = $a->index(9-xvals(10));

puts a single column from C<$a> into C<$b>, and puts a single element
from each column of C<$a> into C<$c>.  If you want to extract multiple
columns from an array in one operation, see L<dice> or L<indexND>.

=cut
EOD

my $index_init_good = 
       'register int foo = $ind(); 
        if( foo<0 || foo>=$SIZE(n) ) {
	   barf("PDL::index: invalid index %d (valid range 0..%d)",
                foo,$SIZE(n)-1);
        }';
my $index_init_bad = 
       'register int foo = $ind(); 
        if( $ISBADVAR(foo,ind) || foo<0 || foo>=$SIZE(n) ) {
	   barf("PDL::index: invalid index %d (valid range 0..%d)",
                foo,$SIZE(n)-1);
        }';

pp_def(
       'index',
       HandleBad => 1,
       DefaultFlow => 1,
       Reversible => 1,	
       Pars => 'a(n); int ind(); [oca] c();',
       Code => 
       $index_init_good . ' $c() = $a(n => foo);',
       BadCode => 
       $index_init_bad . ' $c() = $a(n => foo);',
       BackCode => 
       $index_init_good . ' $a(n => foo) = $c();',
       BadBackCode => 
       $index_init_bad . ' $a(n => foo) = $c();',
       Doc => $doc,
       BadDoc =>
       'index barfs if any of the index values are bad.',
       );

my $index2d_init_good =
       'register int fooa,foob;
	fooa = $inda(); 
        if( fooa<0 || fooa>=$SIZE(na) ) {
           barf("PDL::index: invalid x-index %d (valid range 0..%d)",
                fooa,$SIZE(na)-1);
        }
	foob = $indb(); 
        if( foob<0 || foob>=$SIZE(nb) ) {
	   barf("PDL::index: invalid y-index %d (valid range 0..%d)",
                foob,$SIZE(nb)-1);
        }';
my $index2d_init_bad =
       'register int fooa,foob;
	fooa = $inda(); 
        if( $ISBADVAR(fooa,inda) || fooa<0 || fooa>=$SIZE(na) ) {
           barf("PDL::index: invalid index 1");
        }
	foob = $indb(); 
        if( $ISBADVAR(foob,indb) || foob<0 || foob>=$SIZE(nb) ) {
	   barf("PDL::index: invalid index 2");
        }';

pp_def(
       'index2d',
       HandleBad => 1,
       DefaultFlow => 1,
       Reversible => 1,	
       Pars => 'a(na,nb); int inda(); int indb(); [oca] c();',
       Code => 
       $index2d_init_good . ' $c() = $a(na => fooa, nb => foob);',
       BadCode => 
       $index2d_init_bad . '$c() = $a(na => fooa, nb => foob);',
       BackCode => 
       $index2d_init_good . ' $a(na => fooa, nb => foob) = $c();',
       BadBackCode => 
       $index2d_init_bad . '$a(na => fooa, nb => foob) = $c();',
       Doc => $doc,
       BadDoc =>
       'index2d barfs if either of the index values are bad.',
);


# indexND: CED 2-Aug-2002
pp_add_exported('','indexND indexNDb');
pp_addpm(<<'EOD-indexND');

=head2 indexND

=for ref

Find selected elements in an N-D piddle

=for example

  $out = $source->indexND( $index [, <sever> ] )

  $source = 10*xvals(10,10) + yvals(10,10);
  $index  = pdl([[2,3],[4,5]],[[6,7],[8,9]]);
  print $source->indexND( $index );

  [
   [23 45]
   [67 89]
  ]

IndexND collapses C<$index> by lookup into C<$source>.  The 
0th dimension of C<$index> is treated as coordinates in C<$source>, and 
the return value has the same dimensions as the rest of C<$index>.
The returned elements are looked up from C<$source>.  Dataflow
works -- propagated assignment flows back into C<$source>.  

The C<sever> flag is used to speed up operations where you don't need
flowback: normally, the PDL engine has to keep an enumerated list
of all the relevant pointers in the output PDL, to maintain flow.
If you don't need flowback, setting C<sever> to 1 will significantly
speed up the indexing operation.  The flag is included because the
speedup happens inside indexND.

You can get out hyperplanes from $source, too, in the same way as with
ordinary slicing: use a lower-order vector for the index, and the extra 
source dimensions are stuck on the end of the output dimension list.  
Here's an example, using the same index PDL as above but a 
higher-dimensional source:

  $source = 100*xvals(10,10,2)+10*yvals(10,10,2)+zvals(10,10,2);
  $index  = pdl([[2,3],[4,5]],[[6,7],[8,9]]);
  print $source->indexND( $index );

  [
   [
    [230 450]
    [670 890]
   ]
   [
    [231 451]
    [671 891]
   ]
  ]

WARNING: To save time, no boundary checking is done!  Indices outside
the boundaries of the original array are handled, er, poorly -- you can
get anything from the wrong element (wrapped) to a slice-out-of-bounds
error if you're out of bounds.  L<indexBDb|indexNDb> does boundary 
checking.

The natural counterpart to indexND is L<whichND|whichND>, which generates
appropriate lists of coordinates for indexND.  See also
L<indexNDb|indexNDb>, which handles boundary conditions gracefully, and
L<interpND|interpND>, which handles floating-point index piddles.

This routine is written in perl.  It should probably be written in C;
that would make it run considerably faster.

=cut

sub PDL::indexND {
  my($pdl) = PDL::pdl('PDL',shift);
  my($ipdl)= PDL::pdl('PDL',shift);
  my($sever) = shift;

  $ipdl = $ipdl->dummy(0,1) if($ipdl->getndims < 1);

  ##########
  # $idim0 gets the indexing vectors.
  # @idims gets all remaining dimensions
  my($idim0,@idims) = $ipdl->dims;

  ##########
  # Add dummy dimensions of order 1 to the source PDL until there are 
  # enough dimensions to satisfy the index...
  while(($rank = $pdl->getndims) < $idim0) {
    $pdl = $pdl->dummy(-1,1);
  }

  ##########
  # Record extra dimensions for addition at the end...
  my(@source_dims) = $pdl->dims;
  my(@extra_dims) = splice(@source_dims,$idim0);

  ##########
  # Don't check bounds -- too slow!
  # my($clipped_ipdl) = $ipdl->clip( 0, PDL::pdl('PDL',@source_dims) - 1);
  # barf "indexND: Index out of range" if(($clipped_ipdl != $ipdl)->sum);

  ##########
  # Generate multipliers to flatten the original pdl
  my($mult) = ones($idim0);
  my($i);
  for $i(0..($idim0-2)) {
    # use $tmp for 5.005_03 compatibility
    (my $tmp = $mult->index($i+1)) .= $mult->index($i) * $source_dims[$i];
  }

  ########## 
  # Make the slice, using index (where we can, because it's fast) or 
  # dice (where we have to because there are extra dimensions in the source), 
  # and then reshape it to the desired output dimension.  
  # Two major cases involve whether the output be severed or no.
  if($sever) {
    if(scalar(@extra_dims)==0) {
      return ($pdl -> flat -> index( ($ipdl * $mult)->sumover->flat )
	      -> sever -> reshape(@idims)
	      );
    }
    return ($pdl -> clump($idim0) -> dice( ($ipdl * $mult)->sumover->flat )
	    -> sever -> reshape((@idims,@extra_dims))
	    );
  }	
  
  if(scalar(@extra_dims)==0) {
    return ($pdl -> flat -> index( ($ipdl * $mult)->sumover->flat )
	      -> reshape(@idims)
	  );
  }
  return ($pdl -> clump($idim0) -> dice( ($ipdl * $mult)->sumover->flat )
	      -> reshape((@idims,@extra_dims))
	  );
}
EOD-indexND


pp_addpm(<<'EOD-indexNDb');

=head2 indexNDb

=for ref

Find selected elements in an N-D piddle, with boundary handling

=for example

   $source = 10*xvals(10,10)+yvals(10,10);
   $index = pdl([[-1,3],[4,5]],[[6,7],[8,23]]);
   $out = indexNDb($source, $index);

   $out = indexNDb($source, $index, $method, $missing);

C<indexNDb> collapses C<$index> by lookup into C<$source>, with boundary
condition handling using the given method (if present).  

C<$method> can be one of:

=over 3

=item  periodic

the original array is taken to describe an N-torus.

=item extend 

the indices are clipped to the correct dimension, effectively duplicating
the values at the boundaries out to infinity.

=item truncate

missing values get 0 or the missing value that you feed in (or BAD,
eventually -- but BAD values aren't supported at present).  Because
``truncate'' involves inserting values that aren't necessarily present
in the original array, it returns a I<copy> of the data rather than an
ordinary slice-by-reference, so you can't flow values back to the
original array.

=item forbid

missing values cause an "out of bounds" barf.

=back

C<indexNDb> is different than C<indexND> only because it includes
extra overhead for handling boundary values.

This routine is written in perl.  It should probably stay that way
as the performance hit isn't so bad (though its engine, L<indexND|indexND>,
probably should be written in C).

=cut

# indexNDb: CED 7-Aug-2002

sub PDL::indexNDb{ 
  my($source,$index,$method,$bad) = @_;

  my($index_limits) = ones($index->dim(0));
  my($source_size) = pdl($source->dims);

  if($source_size->nelem < $index_limits->nelem) {
    # use $tmp for 5.005_03 compatibility
    (my $tmp = $index_limits->slice("0:".($source_size->nelem-1))) 
       .= $source_size;
  } else {
    $index_limits .= $source_size->slice("0:".($index_limits->nelem-1));
  }
  
  my($ind);

  if($method =~ m/ext/i || $method =~ m/trunc/i) { # extend or truncate

    $ind = $index->clip(0,$index_limits - 1);

  } elsif ($method =~ m/per/i) { # periodic

   $ind = $index % $index_limits;

  } elsif ($method =~ m/for/i) { # forbid

    $ind = $index->clip(zeroes($index_limits),$index_limits);
    if(sum($ind != $index)) {
      barf "Index out of bounds in indexNDb\n";
    }

  } else { # default (extend)

    $ind = $index->clip(0,$index_limits - 1);
    
    print "indexNDb: unrecognized method '$method'; using default (extend).\n"
      if($PDL::debug && defined $method);
  }
    
  my($retval) =  $source->indexND($ind);

  if($method =~ m/trunc/i) {
    $retval = $retval->copy; 
    my($ind2) = whichND( ($ind != $index)->sumover );
    # use $tmp for 5.005_03 compatibility
    (my $tmp = $retval->indexND($ind2)) .= (defined $bad ? $bad : 0.0);
  }    
  
  return $retval;
}

EOD-indexNDb

pp_addpm(<<'EOD-range');

sub PDL::range {
 my($source,$index,$size,$bound) = @_;
 
 $size = 1 unless defined($size);
 $bound = 0 unless defined($bound);

 $source->rangeb($index,$size,$bound);
}
EOD-range


pp_def(
	'rangeb',
	Doc => <<'EOD',
=for ref

Engine for L<range|range>

=for example

Same calling convention as L<range|range>, but you must supply all
parameters.  

=cut

=head2 range

=for ref 

Extract selected chunks from a source piddle, with boundary conditions

=for example

	$out = $source->range($indices,[$size,[$boundary]])

Returns a rectangular slice of the original piddle, indexed by the index
piddle.

$source is an N-dimensional piddle, and $indices is a 2-dimensional
NxM-piddle, specifying M separate ranges to extract into the single
return piddle.  (You may omit the second dimension if M=1).  

$size may be either a scalar or an N-piddle, and it specifies the
dimensions of the output array.  If you want only single elements, you
may omit $size. 

$boundary is a single number or string, indicating the type of boundary
conditions to use when ranges reach the edge of $source:

=over 3

=item 0 (synonyms: 'f','forbid') B<(default)>

Ranges aren't allowed to cross the boundary of the original PDL.  Disallowed
ranges throw an error.  The errors are thrown at evaluation time, not
at the time of the range call (this is the same behavior as L<slice|slice>).

=item 1 (synonyms: 't','truncate')

Values outside the original piddle get 0 or BAD.  Reverse dataflow is disabled
when this option is set.  B<NOT IMPLEMENTED YET>

=item 2 (synonyms: 'e','extend')

Values that would be outside the original piddle point instead to the 
nearest allowed value within the piddle.  See the CAVEAT below on reverse 
mappings that aren't single valued.

=item 3 (synonyms: 'p','periodic')

Periodic boundary conditions apply: the numbers in $index are applied,
strict-modulo the corresponding dimensions of $source.  This is equivalent to
duplicating the $source piddle throughout dimension space.

=back

Dimensions of $source are threaded over -- ie if $source has N+K dimensions
then the $out gets K extra dimensions, each of which runs over the full
size of the corresponding dimension in $source.

C<range> does single-list threading over the index.  Because implicit
threading can happen in two ways, a little thought is needed.
The returned dimension list is stacked up like so:

	(list thread dim),(index dims (size)),(implicit thread dims)

Note that the list thread dim is always allocated, even if you only want one
range.  That's to avoid confusion between the list thread dim and possible
implicit thread dims at the end of the dimension list.


B<Dataflow>: Dataflow is bidirectional.

B<Examples>:
Here are basic examples of C<range> operation, showing how to get 
ranges out of a small matrix.  The first few examples show extraction
and selection of individual chunks.  The last example shows
how to mark loci in the original matrix (using dataflow).

    perldl> $src = 10*xvals(10,5)+yvals(10,5)
    perldl> print $src->range(pdl(2,3),1)  # Cut out a single element
    [
     [
      [23]
     ]
    ]

    perldl> print $src->range(pdl(2,3), pdl(2,1)) # Cut a 2x1 chunk
    [
     [
      [23]
      [33]
     ]
    ]

    perldl> print $src->range(pdl([2,3],[0,1]), pdl(2,1)) # two 2x1 chunks
    [
     [
      [23  1]
      [33 11]
     ]
    ]

    perldl> print $src->range(pdl([2,3],[0,1]),pdl(2,1))->((0)) # 0th chunk
    [
     [23 33]
    ]

    perldl> $src = xvals(5,3)*10+yvals(5,3)
    perldl> print $src->range(3,1)  /* Thread over y dimension in $src */
    [
     [
      [30]
     ]
     [
      [31]
     ]
     [
      [32]
     ]
    ]
   
    perldl> $src = zeroes(5,4);
    perldl> $src->range(pdl([2,3],[0,1]),pdl(2,1)) .= xvals(2,2,1) + 1
    perldl> print $src
    [
     [0 0 0 0 0]
     [2 2 0 0 0]
     [0 0 0 0 0]
     [0 0 1 1 0]
    ]

B<CAVEAT>: It's quite possible to select multiple ranges that
intersect.  In that case, modifying the ranges doesn't have a
guaranteed result in the original PDL -- the result is an arbitrary
choice among the valid values.  For some things that's OK; but for
others it's not. In particular, this doesn't work:

    perldl> $photon_list = new PDL::RandVar->sample(500)->reshape(2,250)*10
    perldl> histogram = zeroes(10,10)
    perldl> histogram->range($photon_list,1)++;  #not what you wanted

The reason is that if two photons land in the same bin, then that bin 
doesn't get incremented twice.  (That may get fixed in a later version...)

B<Efficiency>: Because C<range> isn't an affine transformation (it
involves lookup into a single list of N-D indices), it is somewhat
memory-inefficient for long lists of ranges, and keeping dataflow open
is somewhat slower than for affine transformations (which don't have
to copy data around).  Thus, if you have a few very large (order of
10^4 element) chunks, you might find that perl lists of ordinary
slices are faster.

C<range> is a perl front-end to a PP function, C<rangeb>.  Calling
C<rangeb> is marginally faster but requires that you include all arguments.

=cut
EOD
	HandleBad => 1,
	DefaultFlow => 1,
	Reversible => 1,
	P2Child => 1,
# Get all parameters in as SVs even though they're meant to be interpreted
# as PDLs -- because the PP signature syntax can't handle the cross-level
# comparison between order of 0th dimension and number of dimensions.
	OtherPars => 'SV *index; SV *size; SV *boundary',

# nitems: number of list elements
# idim:   dimensions of the index (size of parallelpiped)
# lowerbound, upperbound: range of each parallelpiped
# poff: Computed offset in the parent array of each lower-bound address
#       (calculated in RedoDims).
# ctr: Dimension counter used in EquivCPOffsCode.
# 
	Comp => 'long nitems; long idim; 
		 long lowerbound[$COMP(idim) * $COMP(nitems)]; 
		 long upperbound[$COMP(idim) * $COMP(nitems)];
		 long poff[$COMP(nitems)];
		 long sizes[$COMP(idim)];
		 long ctr[$COMP(idim) + PDL_NDIMS];
	         short boundary;
		 ',
#
# MakeComp is complicated a bit by the fact that (as of 21-Aug-2002)
# temporary piddles don't seem to be implemented (see "pdl_converttype"
# in pdlconv.c -- dies if you try to make a temporary cast -- and 
# "pdl_create" in pdlcore.c -- dies if you try to make a mortal piddle.)
# Since the indices could be any type we have to coerce them into 
# the correct type (long).  If that wouldn't involve any loss of information
# (ie they're already char or short or long) then the indices get changed
# in place to save time on the next iteration (assuing that there will
# be one).  Otherwise, we have to make a temporary copy and coerce that.
#
	MakeComp => <<'EOD-MakeComp',
		pdl *ind_pdl;
		pdl *size_pdl;
		long i,j;
		

		/***
		* Check and condition the boundary parameter
		*/
		{
		 char *s;
		 STRLEN len;
		 SV *foo;
		 if(SvROK(boundary))
			foo = SvRV(boundary);
		 else
			foo = boundary;
		
		 s = SvPV(boundary,len);
		 switch(*s) {
			case '0': case 'f': case 'F': default:
			/* forbid */ 
			  $COMP(boundary) = 0;
			  break;
			case '1': case 't': case 'T': 
		        /* truncate */
			  $CROAK("Truncation not yet allowed");
			  break;
	  	        case '2': case 'e': case 'E':
			/* extend */
			 $COMP(boundary) = 2;
			 break;
			case '3': case 'p': case 'P':
			/* periodic */
			 $COMP(boundary) = 3;
			 break;
	         }
		}

		/***
		* Check and condition the index piddle
		* Some of this is apparently done by XS -- but
		* XS doesn't check for existing SVs that are undef
		*/		
		
		if( (index == NULL) || (index == &PL_sv_undef) ){
		  $CROAK("index variable must be defined");
		}
			
		
		ind_pdl = PDL->SvPDLV(index);
		if(!ind_pdl)  {
			$CROAK("unable to convert index to a PDL");
		}

		PDL->make_physdims(ind_pdl);

		if(ind_pdl->nvals == 0) {
			$CROAK("Cannot use the empty PDL as an index");
		}		

		if(ind_pdl->ndims > 2) {
		  $CROAK("Only 1 thread dimension allowed in the index PDL");
		}
		

		/* Convert the index as necessary.  If there's
	           no loss of information, upgrade the index to long;
		   otherwise, make a temporary copy.
		 */
		switch(ind_pdl->datatype) {
			case PDL_B: case PDL_S: case PDL_US:
				PDL->converttype(&ind_pdl,PDL_L,1);
				break;
			case PDL_L:
			default:
				ind_pdl = PDL->hard_copy(ind_pdl);
				PDL->converttype(&ind_pdl,PDL_L,1);
				break;
		}

		/***
		* Allocate the coordinate-storage arrays...
		*/
		
		$COMP(idim) = ind_pdl->ndims ? ind_pdl->dims[0] : 1;
		$COMP(nitems) = ind_pdl->ndims==2 ? ind_pdl->dims[1] : 1;

		$DOCOMPDIMS();

		/***
		* Check and condition the size piddle, and store sizes
		*/
		
		if( (size == NULL) || (size == &PL_sv_undef) ) {
			for(i=0;i<$COMP(idim);i++) 
				$COMP(sizes[i]) = 1;
		} else { /* we got a value */
			size_pdl = PDL->SvPDLV(size); 
			if(!size_pdl){
				$CROAK("Unable to convert size to a PDL\n");
			}

			if(size_pdl->nvals == 0) {
				for(i=0;i<$COMP(idim);i++)
					$COMP(sizes[i])=1;
			} else { /* the piddle is nonempty */

				/* Convert to long 
				 * If there's no loss of information,
				 * upgrade it to long; otherwise, make
				 * a temporary copy.
				 */
				switch(size_pdl->datatype) {
				  PDL_B: PDL_S: PDL:US:
				      PDL->converttype(&size_pdl,PDL_L,1);
				      break;
				  PDL_L:
				    break;
				 default:
				      size_pdl =  PDL->hard_copy(size_pdl);
				      PDL->converttype(&size_pdl,PDL_L,1);
				    break;
				}
				/* Empty piddle -- use 1 everywhere */
				if( size_pdl->nvals == 0 ) {

				    for(i=0;i<$COMP(idim);i++)
					$COMP(sizes[i]) = 1;
				}
				/* One value -- duplicate it everywhere */
				else if( size_pdl->nvals == 1) {
				    for(i=0;i<$COMP(idim);i++)
					$COMP(sizes[i]) = *((long *)(size_pdl->data));
				}
				/* Correct number of values -- copy them in */
				else if( size_pdl->nvals == $COMP(idim) && 
					 size_pdl->ndims == 1 ) {

				    for(i=0;i<$COMP(idim);i++)
					$COMP(sizes[i]) = ((long *)(size_pdl->data))[i];
				}
				/* Incorrect no. of values -- throw an error */
				else {
					$CROAK("Size piddle must match index piddle's 0th dim");
				}
		
			} /* End of nonempty piddle stuff */
		} /* end of size stashination */

		/* Stash starting and ending coordinates in the list */
		    for(i = 0; i < $COMP(nitems); i++) {
		      for(j=0; j < $COMP(idim); j++) {
			long lower,upper;
			lower = ((long *)(ind_pdl->data)) [ 
					i * ind_pdl->dimincs[1] + 
					j * ind_pdl->dimincs[0] 
				   ];
			upper = lower + $COMP(sizes[j]) - 1;


/* fprintf(stderr,"\tSetting lowerbound[%d] (%d*%d + %d) = %d\n",i*($COMP(idim))+j,i,$COMP(idim),j,lower);*/
			$COMP(lowerbound[i * $COMP(idim) + j]) = lower;
			$COMP(upperbound[i * $COMP(idim) + j]) = upper;

		    }
		  }

/* 	fprintf(stderr,"range:makecomp finished\nnitems %d\tidim %d\n",$COMP(nitems),$COMP(idim));*/
/* 		fprintf(stderr,"bounds:");*/
/*		for(i=0;i<$COMP(idim);i++) */
/* 	fprintf(stderr," %d-%d ",$COMP(lowerbound[i]),$COMP(upperbound[i]));*/

		$SETREVERSIBLE(1);
/* 	fprintf(stderr,"\nbye!\n");*/

EOD-MakeComp

	RedoDims => <<'EOD-RedoDims' ,
		long tdim;   /* Surviving thread dims */
	 	long i,j;
		long inc;
		char errflag = 0;

/* 	fprintf(stderr,"range::redodims...\n");*/

		tdim = $PARENT(ndims)- $COMP(idim) ;
		tdim = (tdim > 0) ? tdim : 0;

/* 	fprintf(stderr,"setting dims to %d (1 + %d + %d) ...\n",1+$COMP(idim)+tdim,$COMP(idim),tdim);		*/
		$CHILD(ndims) = 1 + $COMP(idim) + tdim;
		$SETNDIMS(1 + $COMP(idim) + tdim);
/* 	fprintf(stderr,"setting dim 0 to %d (nitems)\n",$COMP(nitems));*/

		$CHILD(dims[0]) = $COMP(nitems);
		$CHILD(dimincs[0]) = 1;

	 	j=1;
		inc = $COMP(nitems);

		/*******
	         *  Copy dims that are indexed, check for out-of-bounds, and
		 *  generate parent 1-D offsets 
		 */
		for(i=0;i<$COMP(nitems);i++) 
			$COMP(poff[i]) = 0;

		for(i=0;i<$COMP(idim);i++,j++) {
		   long ulim;
		   long k;
/* 	fprintf(stderr,"setting dim %d to %d (sizes[%d])\n",j,$COMP(sizes[i]),i);*/
		   ulim= (i<($PARENT(ndims))) ? ( $PARENT(dims[i])) : 1 ;

		   for(k=0;k< ($COMP(nitems)) ; k++) {
			
		      /* Check range if boundary conditions are turned off */
		      if(!($COMP(boundary)) && 
			 (($COMP(lowerbound)[ k * ($COMP(idim)) + i] < 0) ||
			 ($COMP(upperbound)[ k * ($COMP(idim)) + i] >= ulim))) {
			   $CHILD(ndims) = 0;
			   $SETNDIMS(0);
			   $SETDIMS();
			   $CROAK("Range out of bounds\n");
		      }

		      ($COMP(poff))[k] += 
			   ($PARENT(dimincs))[i] * 
			   ($COMP(lowerbound))[ k * ($COMP(idim)) + i];
/* 	fprintf(stderr,"\tpoff[%d] = %d\n",k,$COMP(poff[k]));*/

		   }
	
		   ($CHILD(dims))[j] = ($COMP(sizes))[i];
		   /* The 0 here makes it a dummy dimension! */
		   ($CHILD(dimincs))[j] = (i<($PARENT(ndims))) ? inc : 0;
		   inc *= ($CHILD(dims))[j];
	  	}

		/* Copy threaded-over dims */
		for(;i<$PARENT(ndims);i++,j++) {
/* 	fprintf(stderr,"setting dim %d to %d (thread[%d])\n",j,$PARENT(dims[i]),i);*/
			$CHILD(dims[j]) = $PARENT(dims[i]);
			$CHILD(dimincs[j]) = inc;
			inc *= ($CHILD(dims[j]));
		}

		$CHILD(datatype) = $PARENT(datatype);
		$SETDIMS();

EOD-RedoDims

	EquivCPOffsCode => <<'EOD-EquivCPOffsCode',
		long dim, item;
		long tdim, total_dim, nperitem;
		long bound_index;   /* index into boundary array */
		long ptoff,ctoff;   /* parent and child offsets */
		long *ctr;

		/* number of copies to make per item in the list */
		nperitem = $CHILD_P(nvals) / $COMP(nitems);
/* 	fprintf(stderr,"nitems = %d; nperitem=%d\n",$COMP(nitems),nperitem);*/


		if(($CHILD_P(ndims)) > $COMP(idim) + (PDL_NDIMS)) 
			ctr = (long *)(PDL->smalloc($CHILD_P(ndims)));
		else
			ctr = $COMP(ctr);

		for(dim=0;dim<($CHILD_P(ndims));dim++)
			ctr[dim] = 0;

		/* No boundary condition case:  the offsets are linearly
		 * related, so we can calculate an overall offset for 
		 * position within the range, and then loop over 
		 * items (ranges), adding offsets as we go.
		 * -CED
		 */
		if($COMP(boundary) == 0){
			do {
			   ptoff = ctoff = 0;
	
			   /* Calculate offset within each individual range */
			   for(dim=0; dim < ($CHILD_P(ndims))-1; dim++) {
			      if(dim < ($PARENT_P(ndims))) 
				ptoff += ($PARENT_P(dimincs))[dim] * ctr[dim];
			      ctoff += ($CHILD_P(dimincs))[dim+1] * ctr[dim];
			   }
	
			   /* No boundary condition handling */
			   for(item = 0; item < $COMP(nitems); item++) {
				long a = $CHILD_P(dimincs[0])*item + ctoff;
				long b = $COMP(poff[item])         + ptoff;
				$EQUIVCPOFFS(a,b);
			   }
				
	
			   /* Increment element within range */
			   for(dim=1; dim < ($CHILD_P(ndims));  dim++) {
				if( (++(ctr[dim-1])) >= $CHILD_P(dims[dim]))
					ctr[dim-1] = 0;
				else
					break;
			   }
			} while(dim < $CHILD_P(ndims)); /* Checks result of inc loop */
		} else { 
		  /* Boundary condition case: the offsets aren't necessarily
		   * linearly related.  This stuff is pretty stoopid: we just
		   * explicitly recalculate the offset for every single point,
		   * truncating or periodicizing or whatever for every 
		   * offset.  It can be improved by perhaps 30% by being 
		   * smarter about evaluation order, (like un-nesting the
		   * switch) but I'm too lazy to do it.  Wait for Moore's Law
		   * [ (18 months) * log_2(1/30%) ] instead. :-)
		   * -CED
		   */
		  do {
		    for(item = 0; item < $COMP(nitems); item++) {
			long a;


		      /* Calculate offset (with mods) within each range */
		      ptoff = ctoff = 0;

		      switch($COMP(boundary)) {

		        case 1: /* truncation */
				/* barf because $CROAK mysteriously fails */
			      barf("rangeb debug" "truncation not allowed (yet) (This can't happen! Go away!)"); 
			      break;

			case 2: /* extension -- crop parent dims */

			      for(dim=0;dim<($CHILD_P(ndims))-1;dim++) {
				long pd = ctr[dim] + $COMP(lowerbound[item*$COMP(idim)+dim]);
				if(pd < 0) 
					pd=0;
				else if(pd >= $PARENT_P(dims[dim]))
					pd = $PARENT_P(dims[dim])-1;

				
				ptoff += ($PARENT_P(dimincs))[dim] * pd;
				ctoff += ($CHILD_P(dimincs))[dim+1] * ctr[dim];
			      }
			      break;	

			case 3: /* periodic -- parent dims modulo size */
			      for(dim=0;dim<($CHILD_P(ndims))-1;dim++) {
				long pd = ctr[dim] + $COMP(lowerbound[item*$COMP(idim)+dim]);
				if(pd < 0) /* Fold up to above zero */
					pd += abs(pd * $PARENT_P(dims[dim]));
				pd %= $PARENT_P(dims[dim]);
				ptoff += ($PARENT_P(dimincs))[dim] * pd;
				ctoff += ($CHILD_P(dimincs))[dim+1]*ctr[dim];
			      }
			      break;

			default:
				/* barf because $CROAK mysteriously fails */
				barf("rangeb debug" "Unknown boundary condition code! This can't happen -- go away!");
				break;
		      } /* end of switch */

		      /* Do the actual data copy */
		      a = $CHILD_P(dimincs[0])*item + ctoff;
		      $EQUIVCPOFFS(a,ptoff);

		    } /* end of item code */
		
		    /* Increment element within range */
		    for(dim=1; dim < ($CHILD_P(ndims));  dim++) {
		      if( (++(ctr[dim-1])) >= $CHILD_P(dims[dim]))
			ctr[dim-1] = 0;
		      else
			break;
		    }
		  } while(dim < $CHILD_P(ndims)); /* Checks result of inc loop */
		}

EOD-EquivCPOffsCode

);

	

pp_def(
	'rld',
	Pars=>'int a(n); b(n); [o]c(m);',
	PMCode =><<'EOD',
sub PDL::rld {
  my ($a,$b) = @_;
  my ($c);
  if ($#_ == 2) {
    $c = $_[2];
  } else {
# XXX Need to improve emulation of threading in auto-generating c
    my ($size) = $a->sumover->max;
    my (@dims) = $a->dims;
    shift @dims;
    $c = $b->zeroes($size,@dims);
  }
  &PDL::_rld_int($a,$b,$c);
  $c;
}
EOD
	Code=>'
	  int i,j=0,an;
	  $GENERIC(b) bv;
	  loop (n) %{
	    an = $a();
	    bv = $b();
	    for (i=0;i<an;i++) {
	      $c(m=>j) = bv;
	      j++;
	    }
	  %}',
	Doc => <<'EOD'
=for ref

Run-length decode a vector

Given a vector C<$a> of the numbers of instances of values C<$b>, run-length
decode to C<$c>.

=for example

 rld($a,$b,$c=null);

=cut
EOD
);
pp_def(
	'rle',
	Pars=>'c(n); int [o]a(n); [o]b(n);',
	Code=>'
	  int j=0,sn=$SIZE(n);
	  $GENERIC(c) cv, clv;
	  clv = $c(n=>0);
	  $b(n=>0) = clv;
	  $a(n=>0) = 0;
	  loop (n) %{
	    cv = $c();
	    if (cv == clv) {
	      $a(n=>j)++;
	    } else {
	      j++;
	      $b(n=>j) = clv = cv;
	      $a(n=>j) = 1;
	    }
	  %}
	  for (j++;j<sn;j++) {
	    $a(n=>j) = 0;
	    $b(n=>j) = 0;
	  }
	',
	Doc => <<'EOD'
=for ref

Run-length encode a vector

Given vector C<$c>, generate a vector C<$a> with the number of each element,
and a vector C<$b> of the unique values.  Only the elements up to the
first instance of `0' in C<$a> should be considered.

=for example

 rle($c,$a=null,$b=null);

=cut
EOD
);

# this one can convert vaffine piddles without(!) physicalising them
# maybe it can replace 'converttypei' in the future?
#
# XXX do not know whether the HandleBad stuff will work here
#
pp_def('flowconvert',
       HandleBad => 1,
       DefaultFlow => 1,
       Reversible => 1,	
       Pars => 'PARENT(); [oca]CHILD()',
       OtherPars => 'int totype;',
       Reversible => 1,
       # Forced types
       FTypes => {CHILD => '$COMP(totype)'},
       Code => 
       '$CHILD() = $PARENT();',
       BadCode => 
       'if ( $ISBAD(PARENT()) ) { 
           $SETBAD(CHILD());
        } else {
           $CHILD() = $PARENT();
        }',
       BackCode => '$PARENT() = $CHILD();',
       BadBackCode => 
       'if ( $ISBAD(CHILD()) ) { 
           $SETBAD(PARENT());
        } else {
           $PARENT() = $CHILD();
        }',
       Doc => 'internal',
);


pp_def(
	'converttypei',
        HandleBad => 1,
	DefaultFlow => 1,
	GlobalNew => 'converttypei_new',
	OtherPars => 'int totype;',
	P2Child => 1,
	Identity => 1,
	Reversible => 1,
# Forced types
	FTypes => {CHILD => '$COMP(totype)'},
	Doc => 'internal',
);



# XXX Make clump work with optional parameter!
if(0) {
# Special-case
pp_def(
	'clump',
	DefaultFlow => 1,
	OtherPars => 'int n',
	P2Child => 1,
	Priv => 'int nnew; int nrem;',
	RedoDims => 'int i; int d1;
		if($COMP(n) > $PARENT(ndims)) 
			/* Now with more flavor: truncate overly long clumps to 
			   just clump existing dimensions...  (CED 17-Mar-2002) */

			$COMP(n) = $PARENT(ndims);

			/* Old croaking code: */
			/*$CROAK("Too many dimensions %d to clump from %d", */
			/*		$COMP(n),$PARENT(ndims)); */

		 $COMP(nrem) = ($COMP(n)==-1 ? $PARENT(threadids[0]) : $COMP(n));
		 $PRIV(nnew) = $PARENT(ndims) - $COMP(nrem) + 1;
		 $SETNDIMS($PRIV(nnew));
		 d1=1;
		 for(i=0; i<$PRIV(nrem); i++) {
		 	d1 *= $PARENT(dims[i]);
		 }
		 $CHILD(dims[0]) = d1;
		 for(; i<$PARENT(ndims); i++) {
		 	$CHILD(dims[i-$PRIV(nrem)+1]) = $PARENT(dims[i]);
		 }
		 $SETDIMS();
		 $SETDELTATHREADIDS(1-$COMP(nrem));
		 ',
	EquivCPOffsCode => '
		int i;
		for(i=0; i<$CHILD_P(nvals); i++) {
			$EQUIVCPOFFS(i,i);
		}
		',
	Reversible => 1,
);
} else {

# Affine! Make sure vaffine chaining understands to stop in the right
# place.
# the perl wrapper clump is now defined in Core.pm
# this is just the low level interface
pp_def(
	'_clump_int',
	P2Child => 1,
	DefaultFlow => 1,
	Reversible => 1,
	AffinePriv => 1,
	OtherPars => 'int n',
	RedoDims => 'int i; int d1;
		int nrem; int nnew;
		if($COMP(n) > $PARENT(ndims)) {
			/* Now with more flavor:  truncate clumping in this case to 
			 * the total number of dimensions that actually exist...
			 *  --CED 17-Mar-2002
			 */
 			$COMP(n) = -1;
			
#ifdef older_croaking_code
			$SETNDIMS(0);  /* fix to make sure we do not get problems later */
			$PRIV(offs) = 0;
			$SETDIMS();
			$CROAK("Too many dimensions %d to clump from %d",
				$COMP(n),$PARENT(ndims));
#endif
		}
		 nrem = ($COMP(n)==-1 ? $PARENT(threadids[0]) : $COMP(n));
		 nnew = $PARENT(ndims) - nrem + 1;
		 $SETNDIMS(nnew);
		 $DOPRIVDIMS();
		 $PRIV(offs) = 0;
		 d1=1;
		 for(i=0; i<nrem; i++) {
		 	d1 *= $PARENT(dims[i]);
		 }
		 $CHILD(dims[0]) = d1;
		 $PRIV(incs[0]) = 1;
		 for(; i<$PARENT(ndims); i++) {
		 	$CHILD(dims[i-nrem+1]) = $PARENT(dims[i]);
			$PRIV(incs[i-nrem+1]) = $PARENT(dimincs[i]);
		 }
		 $SETDIMS();
		 $SETDELTATHREADIDS(1-nrem);
		 ',
	Doc => 'internal',
);
}

pp_def(
	'xchg',
	OtherPars => 'int n1; int n2;',
	DefaultFlow => 1,
	Reversible => 1,
	P2Child => 1,
	XCHGOnly => 1,
	EquivDimCheck => 'if ($COMP(n1) <0)
				$COMP(n1) += $PARENT(threadids[0]);
			  if ($COMP(n2) <0)
				$COMP(n2) += $PARENT(threadids[0]);
			  if ($COMP(n1) <0 ||$COMP(n2) <0 ||
			     $COMP(n1) >= $PARENT(threadids[0]) ||
			     $COMP(n2) >= $PARENT(threadids[0]))
		barf("One of dims %d, %d out of range: should be 0<=dim<%d",
			$COMP(n1),$COMP(n2),$PARENT(threadids[0]));',
	EquivPDimExpr => '(($CDIM == $COMP(n1)) ? $COMP(n2) : ($CDIM == $COMP(n2)) ? $COMP(n1) : $CDIM)',
	EquivCDimExpr => '(($PDIM == $COMP(n1)) ? $COMP(n2) : ($PDIM == $COMP(n2)) ? $COMP(n1) : $PDIM)',
	Doc => <<'EOD',
=for ref

exchange two dimensions

Negative dimension indices count from the end.

The command

=for example

 $b = $a->xchg(2,3);

creates C<$b> to be like C<$a> except that the dimensions 2 and 3
are exchanged with each other i.e.

 $b->at(5,3,2,8) == $a->at(5,3,8,2)

=cut
EOD
);

pp_addpm(<< 'EOD');

=head2 reorder

=for ref

Re-orders the dimensions of a PDL based on the supplied list.

Similar to the L<xchg|/xchg> method, this method re-orders the dimensions
of a PDL. While the L<xchg|/xchg> method swaps the position of two dimensions,
the reorder method can change the positions of many dimensions at
once.

=for usage

 # Completely reverse the dimension order of a 6-Dim array.
 $reOrderedPDL = $pdl->reorder(5,4,3,2,1,0); 

The argument to reorder is an array representing where the current dimensions
should go in the new array. In the above usage, the argument to reorder 
C<(5,4,3,2,1,0)>
indicates that the old dimensions (C<$pdl>'s dims) should be re-arranged to make the
new pdl (C<$reOrderPDL>) according to the following:

   Old Position   New Position
   ------------   ------------
   5              0
   4              1
   3 		  2
   2		  3
   1		  4
   0		  5

=for example 

Example:

 perldl> $a = sequence(5,3,2);	  # Create a 3-d Array
 perldl> p $a
 [
  [
   [ 0  1  2  3  4]
   [ 5  6  7  8  9]
   [10 11 12 13 14]
  ]
  [
   [15 16 17 18 19]
   [20 21 22 23 24]
   [25 26 27 28 29]
  ]
 ]
 perldl> p $a->reorder(2,1,0); # Reverse the order of the 3-D PDL
 [
  [
   [ 0 15]
   [ 5 20]
   [10 25]
  ]
  [
   [ 1 16]
   [ 6 21]
   [11 26]
  ]
  [
   [ 2 17]
   [ 7 22]
   [12 27]
  ]
  [
   [ 3 18]
   [ 8 23]
   [13 28]
  ]
  [
   [ 4 19]
   [ 9 24]
   [14 29]
  ]
 ]

The above is a simple example that could be duplicated by calling
C<$a-E<gt>xchg(0,2)>, but it demonstrates the basic functionality of reorder.

As this is an index function, any modifications to the
result PDL will change the parent.

=cut

sub PDL::reorder {
	my ($pdl,@newDimOrder) = @_;
	
	my $arrayMax = $#newDimOrder;
  
	#Error Checking:
	if( $pdl->getndims != scalar(@newDimOrder) ){
		my $errString = "PDL::reoderDims: Number of elements (".scalar(@newDimOrder).") in newDimOrder array doesn't\n";
		$errString .= "match the number of dims in the supplied PDL ($ndims)\n";
		barf($errString);
	}
	# a quicker way to do the reorder
	return $pdl->thread(@newDimOrder)->unthread(0);
}

EOD

pp_def(
	'mv',
	OtherPars => 'int n1; int n2;',
	DefaultFlow => 1,
	Reversible => 1,
	P2Child => 1,
	XCHGOnly => 1,
	EquivDimCheck => 'if ($COMP(n1) <0)
				$COMP(n1) += $PARENT(threadids[0]);
			  if ($COMP(n2) <0)
				$COMP(n2) += $PARENT(threadids[0]);
			  if ($COMP(n1) <0 ||$COMP(n2) <0 ||
			     $COMP(n1) >= $PARENT(threadids[0]) ||
			     $COMP(n2) >= $PARENT(threadids[0]))
		barf("One of dims %d, %d out of range: should be 0<=dim<%d",
			$COMP(n1),$COMP(n2),$PARENT(threadids[0]));',
	EquivPDimExpr => '(($COMP(n1) < $COMP(n2)) ?
	(($CDIM < $COMP(n1) || $CDIM > $COMP(n2)) ?
		$CDIM : (($CDIM == $COMP(n2)) ? $COMP(n1) : $CDIM+1))
	: (($COMP(n2) < $COMP(n1)) ?
		(($CDIM > $COMP(n1) || $CDIM < $COMP(n2)) ?
			$CDIM : (($CDIM == $COMP(n2)) ? $COMP(n1) : $CDIM-1))
		: $CDIM))',
	EquivCDimExpr => '(($COMP(n2) < $COMP(n1)) ?
	(($PDIM < $COMP(n2) || $PDIM > $COMP(n1)) ?
		$PDIM : (($PDIM == $COMP(n1)) ? $COMP(n2) : $PDIM+1))
	: (($COMP(n1) < $COMP(n2)) ?
		(($PDIM > $COMP(n2) || $PDIM < $COMP(n1)) ?
			$PDIM : (($PDIM == $COMP(n1)) ? $COMP(n2) : $PDIM-1))
		: $PDIM))',
	Doc => << 'EOD',
=for ref

move a dimension to another position

The command

=for example

 $b = $a->mv(4,1);

creates C<$b> to be like C<$a> except that the dimension 4 is moved to the
place 1, so:

 $b->at(1,2,3,4,5,6) == $a->at(1,5,2,3,4,6);

The other dimensions are moved accordingly.
Negative dimension indices count from the end.
EOD
);

pp_def(
	'oneslice',
	Doc => <<'EOD',
=for ref

experimental function - not for public use

=for example

 $a = oneslice();

This is not for public use currently. See the source if you have to.
This function can be used to accomplish run-time changing of
transformations i.e. changing the size of some piddle at run-time.

However, the mechanism is not yet finalized and this is just a demonstration.

EOD
	P2Child => 1,
	DefaultFlow => 1,
	Reversible => 1,
	OtherPars => 'int nth; int from; int step; int nsteps;',
	AffinePriv => 1,
	RedoDims => '
		int nth = $PRIV(nth);
		int from = $PRIV(from);
		int step = $PRIV(step);
		int nsteps = $PRIV(nsteps);
		int i;
		printf("ONESLICE_REDODIMS %d %d %d %d\n",nth,from,step,nsteps);
		if(nth >= $PARENT(ndims)) {
			die("Oneslice: too large nthdim");
		}
		if(from + step * (nsteps-1) >= $PARENT(dims[nth])) {
			die("Oneslice: too many, too large steps");
		}
		if(from < 0 || step < 0) {
			die("Oneslice: can only support positive from & step");
		}
		$PRIV(offs) = 0;
		$SETNDIMS($PARENT(ndims));
		$DOPRIVDIMS();
		for(i=0; i<$PARENT(ndims); i++) {
			$CHILD(dims)[i] = $PARENT(dims)[i];
			$PRIV(incs)[i] = $PARENT(dimincs)[i];
		}
		$CHILD(dims)[nth] = nsteps;
		$PRIV(incs)[nth] *= step;
		$PRIV(offs) += from * $PARENT(dimincs)[nth];
		$SETDELTATHREADIDS(0);
		$SETDIMS();
	',
	FooCode => # This is why we have this stupid function
	'	$COMP(from) = i1;
		$COMP(step) = i2;
		$COMP(nsteps) = i3;
		printf("ONESLICE_FOOFUNC %d %d %d %d\n",
		    $COMP(nth),$COMP(from),$COMP(step),$COMP(nsteps));
	',
);


pp_addhdr << 'EOH';
#define sign(x) ( (x) < 0 ? -1 : 1)
EOH

# I think the quotes in the =item ":" lines
# confuse the perldoc stuff
#
pp_def(
	'slice',
	Doc => << 'EOD',
=for ref

Returns a rectangular slice of the original piddle

=for example

 $a->slice('1:3');  #  return the second to fourth elements of $a
 $a->slice('3:1');  #  reverse the above
 $a->slice('-2:1'); #  return last-but-one to second elements of $a

The argument string is a comma-separated list of what to do
for each dimension. The current formats include
the following, where I<a>, I<b> and I<c> are integers and can
take legal array index values (including -1 etc):

=over 8

=item :

takes the whole dimension intact.

=item ''

(nothing) is a synonym for ":"
(This means that C<$a-E<gt>slice(':,3')> is equal to C<$a-E<gt>slice(',3')>).

=item a

slices only this value out of the corresponding dimension.

=item (a)

means the same as "a" by itself except that the resulting
dimension of length one is deleted (so if C<$a> has dims C<(3,4,5)> then
C<$a-E<gt>slice(':,(2),:')> has dimensions C<(3,5)> whereas
C<$a-E<gt>slice(':,2,:')> has dimensions C<(3,1,5))>.

=item a:b

slices the range I<a> to I<b> inclusive out of the dimension.

=item a:b:c

slices the range I<a> to I<b>, with step I<c> (i.e. C<3:7:2> gives the indices
C<(3,5,7)>). This may be confusing to Matlab users but several other
packages already use this syntax.

=item '*'

inserts an extra dimension of width 1 and

=item '*a'

inserts an extra (dummy) dimension of width I<a>.

=back

An extension is planned for a later stage allowing
C<$a-E<gt>slice('(=1),(=1|5:8),3:6(=1),4:6')>
to express a multidimensional diagonal of C<$a>.

Trivial out-of-bounds slicing is allowed: if you slice a source
dimension that doesn't exist, but only index the 0th element, then
C<slice> treats the source as if there were a dummy dimension there.
The following are all equivalent:
	
	xvals(5)->dummy(1,1)->slice('(2),0')  # Add dummy dim, then slice
	xvals(5)->slice('(2),0')              # Out-of-bounds slice adds dim.
	xvals(5)->slice((2),0)                # NiceSlice syntax
	xvals(5)->((2))->dummy(0,1) 	      # NiceSlice syntax

This is an error:
	
	xvals(5)->slice('(2),1')	# nontrivial out-of-bounds slice dies

Because slicing doesn't directly manipulate the source and destination 
pdl -- it just sets up a transformation between them -- indexing errors 
often aren't reported until later.  This is either a bug or a feature,
depending on whether you prefer error-reporting clarity or speed of execution.

=cut
EOD
	P2Child => 1,
	DefaultFlow => 1,
	OtherPars => 'char* str',
	Comp => 'int nnew; int nthintact; int intactnew; int ndum;
	         int corresp[$COMP(intactnew)]; int start[$COMP(intactnew)];
		 int inc[$COMP(intactnew)]; int end[$COMP(intactnew)];
		 int nolddims;
		 int whichold[$COMP(nolddims)]; int oldind[$COMP(nolddims)];
		 ',
	AffinePriv => 1,
	MakeComp => q~
		int i;
		int nthnew; int nthold; int nthreal;
		int dumsize;
		char *s; char *ns;
		int nums[3]; int nthnum;
		$COMP(nnew)=0;
		$COMP(ndum)=0;
		$COMP(nolddims) = 0;
		if(str[0] == '(')
			$COMP(nolddims)++;
		else if (str[0] == '*')
			$COMP(ndum)++;
		else if (str[0] != '\0') /* handle empty string */
			$COMP(nnew)++;
		for(i=0; str[i]; i++)
			if(str[i] == ',') {
				if(str[i+1] == '(')
					$COMP(nolddims)++;
				else if(str[i+1] == '*')
					$COMP(ndum)++;
				else
					$COMP(nnew)++;
			}
		$COMP(nthintact) = $COMP(nolddims) + $COMP(nnew);
		$COMP(intactnew) = $COMP(nnew)+$COMP(ndum);
		$DOCOMPDIMS();
		nthnew=0; nthold=0; i=0; nthreal=0;
		s=str-1;
		do {
			s++;
			if(isdigit(*s) || *s == '-') {
				nthnew++; nthreal++;
				$COMP(inc[nthnew-1]) = 1;
				$COMP(corresp[nthnew-1]) = nthreal-1;
				$COMP(start[nthnew-1]) = strtol(s,&s,10);
				if(*s != ':') {
					$COMP(end[nthnew-1]) =
						$COMP(start[nthnew-1]);
					goto outlab;
				}
				s++;
				if(!isdigit(*s) && !(*s == '-')) {
					barf("Invalid slice str ind1 '%s': '%s'",str,s);
				}
				$COMP(end[nthnew-1]) = strtol(s,&s,10);
				if(*s != ':') {goto outlab;}
				s++;
				if(!isdigit(*s) && !(*s == '-')) {
					barf("Invalid slice str ind2 '%s': '%s'",str,s);
				}
				$COMP(inc[nthnew-1]) = strtol(s,&s,10);
			} else switch(*s) {
			case ':':
				s++;
				/* FALLTHRU */
			case ',': case '\0':  /* In these cases, no inc s */
				if ($COMP(intactnew) > 0) {
				  $COMP(start[nthnew]) = 0;
				  $COMP(end[nthnew]) = -1;
				  $COMP(inc[nthnew]) = 1;
				  $COMP(corresp[nthnew]) = nthreal;
				  nthnew++; nthreal++;
				}
				break;
			case '(':
				s++;
				$COMP(oldind[nthold]) = strtol(s,&s,10);
				$COMP(whichold[nthold]) = nthreal;
				nthold++; nthreal++;
				if(*s != ')') {
					barf("Sliceoblit must end with ')': '%s': '%s'",str,s);
				}
				s++;
				break;
			case '*':
				s++;
				if(isdigit(*s)) {
					dumsize = strtol(s,&s,10);
				} else {dumsize = 1;}
				$COMP(corresp[nthnew]) = -1;
				$COMP(start[nthnew]) = 0;
				$COMP(end[nthnew]) = dumsize-1;
				$COMP(inc[nthnew]) = 1;
				nthnew++;
				break;
			}
		   outlab:
			if(*s != ',' && *s != '\0') {
				barf("Invalid slice str '%s': '%s'",str,s);
			}
		} while(*s);
		$SETREVERSIBLE(1); /* XXX Only if incs>0, no dummies */
	~,
	RedoDims => '
		int i; int start; int end; int inc;
		if ($COMP(nthintact) > $PARENT(ndims)) {

	/* Slice has more dims than parent.  Check that the extra dims are 		
         * all zero, and if they are then give back What You Probably Wanted,
	 * which is a slice with dummy dimensions of order 1 in place of each excessive 
	 * dimension.  (Note that there are two ways to indicate a zero index: "0" and "-<w>",
	 * where <w> happens to be the order of that dimension in the original
	 * piddle.  The latter case still causes an error.  That is a feature.)
	 *    --CED 15-March-2002
	 */
			int ii,parentdim,ok;
			int n_xtra_dims=0, n_xtra_olddims=0;

			   /* Check index for each extra dim in the ordinary affine list */

			for(ok=1, ii = 0; ok && ii < $COMP(intactnew) ; ii++) {
				parentdim = $COMP(corresp[ii]);
/*				fprintf(stderr,"ii=%d,parent=%d, ndum=%d, nnew=%d...",ii,parentdim,$COMP(ndum),$COMP(nnew));				*/
				if(parentdim >= $PARENT(ndims)) {					

					ok = ( ( $COMP(start[ii]) == 0 ) && 
					  	( $COMP(end[ii]) == 0 || $COMP(end[ii])== -1 )
					);
					if(ok) {
						/* Change this into a dummy dimension, rank 1 */
						$COMP(corresp[ii]) = -1;
						$COMP(start[ii])   = 0;
						$COMP(end[ii])     = 0;
						$COMP(inc[ii])     = 1;
						$COMP(ndum)++;      /* One more dummy dimension... */
						$COMP(nnew)--;      /* ... one less real dimension */
						$COMP(nthintact)--; /* ... one less intact dim */
/*						fprintf(stderr,"ok, ndum=%d, nnew=%d\n",$COMP(ndum), $COMP(nnew));*/
					}
/*				fflush(stderr);*/
				}
			}	
			
			  /* Check index for each indexed parent dimension */
			for(ii=0; ok && ii < $COMP(nolddims); ii++) {
				if($COMP(whichold[ii]) >= $PARENT(ndims)) {
					ok = ( $COMP(whichold[ii]) < $PARENT(ndims) ) ||
						( $COMP(oldind[ii]) == 0 ) ||
						( $COMP(oldind[ii]) == -1) ;
					if(ok) {
					  int ij;
					  /* crunch indexed dimensions -- slow but sure */
					  $COMP(nolddims)--;
					  for(ij=ii; ij<$COMP(nolddims); ij++) {
						$COMP(oldind[ij]) = $COMP(oldind[ij+1]);
					 	$COMP(whichold[ij]) = $COMP(whichold[ij+1]);
					  }
					  $COMP(nthintact)--;
					}
				}
			}	
/*	fprintf(stderr,"ok=%d\n",ok);fflush(stderr);*/
			if(ok) {
			   /* Valid slice: all extra dims are zero. Adjust indices accordingly. */
/*			  $COMP(intactnew) -= $COMP(nthintact) - $PARENT(ndims); */
/*			  $COMP(nthintact) = $PARENT(ndims);*/
			} else { 	

			   /* Invalid slice: nonzero extra dimension.  Clean up and die.  */

  			 $SETNDIMS(0); /* dirty fix */
			 $PRIV(offs) = 0;	
			 $SETDIMS();
			 $CROAK("Too many dims in slice");
			}
 	        }
		$SETNDIMS($PARENT(ndims)-$COMP(nthintact)+$COMP(intactnew));
		$DOPRIVDIMS();
		$PRIV(offs) = 0;
		for(i=0; i<$COMP(intactnew); i++) {
			int parentdim = $COMP(corresp[i]);
			start = $COMP(start[i]); end = $COMP(end[i]);
			inc = $COMP(inc[i]);
			if(parentdim!=-1) {
				if(-start > $PARENT(dims[parentdim]) ||
				   -end > $PARENT(dims[parentdim])) {
					barf("Negative slice cannot start or end above limit");
                                }
				if(start < 0)
					start = $PARENT(dims[parentdim]) + start;
				if(end < 0)
					end = $PARENT(dims[parentdim]) + end;
				if(start >= $PARENT(dims[parentdim]) ||
				   end >= $PARENT(dims[parentdim])) {
					barf("Slice cannot start or end above limit");
				}
				if(sign(end-start)*sign(inc) < 0)
					inc = -inc;
				$PRIV(incs[i]) = $PARENT(dimincs[parentdim]) * inc;
				$PRIV(offs) += start * $PARENT(dimincs[parentdim]);
			} else {
				$PRIV(incs[i]) = 0;
			}
			$CHILD(dims[i]) = ((int)((end-start)/inc))+1;
                        if ($CHILD(dims[i]) <= 0)
                           barf("slice internal error: computed slice dimension must be positive");
		}
		for(i=$COMP(nthintact); i<$PARENT(ndims); i++) {
			int cdim = i - $COMP(nthintact) + $COMP(intactnew);
			$PRIV(incs[cdim]) = $PARENT(dimincs[i]);
			$CHILD(dims[cdim]) = $PARENT(dims[i]);
		}
		for(i=0; i<$COMP(nolddims); i++) {
			int oi = $COMP(oldind[i]);
			int wo = $COMP(whichold[i]);
			if(oi < 0)
				oi += $PARENT(dims[wo]);
			if( oi >= $PARENT(dims[wo]) )
				$CROAK("Cannot obliterate dimension after end");
			$PRIV(offs) += $PARENT(dimincs[wo])
					* oi;
		}
	/*
		for(i=0; i<$CHILD(ndims)-$PRIV(nnew); i++) {
			$CHILD(dims[i+$COMP(intactnew)]) =
				$PARENT(dims[i+$COMP(nthintact)]);
			$PRIV(incs[i+$COMP(intactnew)]) =
				$PARENT(dimincs[i+$COMP(nthintact)]);
		}
	*/
		$SETDIMS();
	',
);

pp_addpm(<<'EOD'

=head2 using

=for ref

Returns array of column numbers requested

=for usage

 line $pdl->using(1,2);

Plot, as a line, column 1 of C<$pdl> vs. column 2

=for example

 perldl> $pdl = rcols("file");
 perldl> line $pdl->using(1,2);

=cut

*using = \&PDL::using;
sub PDL::using {
  my ($x,@ind)=@_;
  @ind = list $ind[0] if (ref $ind[0] eq 'PDL');
  foreach (@ind) {
    $_ = $x->slice("($_)");
  }
  @ind;
}

EOD
);

pp_add_exported('', 'using');

pp_addhdr(<<END
static int cmp_pdll(const void *a_,const void *b_) {
	PDL_Long *a = (PDL_Long *)a_; PDL_Long *b=(PDL_Long *)b_;
	if(*a>*b) return 1;
	else if(*a==*b) return 0;
	else return -1;
}
END
);
	

pp_def( 'affine',
	P2Child => 1,
	DefaultFlow => 1,
	Reversible => 1,
	AffinePriv => 1,
	GlobalNew => 'affine_new',
	OtherPars => 'int offspar; SV *dimlist; SV *inclist;',
	Comp => 'int nd; PDL_Long offset; PDL_Long sdims[$COMP(nd)];
		PDL_Long sincs[$COMP(nd)];',
	MakeComp => '
		int i,n2;
		PDL_Long *tmpi;
		PDL_Long *tmpd = PDL->packdims(dimlist,&($COMP(nd)));
		tmpi = PDL->packdims(inclist,&n2);		
		if ($COMP(nd) < 0) {
		      $CROAK("Affine: can not have negative no of dims");
		}
		if ($COMP(nd) != n2)
		      $CROAK("Affine: number of incs does not match dims");
		$DOCOMPDIMS();
		$COMP(offset) = offspar;
		for (i=0; i<$COMP(nd); i++) {
			$COMP(sdims)[i] = tmpd[i];
			$COMP(sincs)[i] = tmpi[i];
		}
		',
	RedoDims => '
		int i;
		$SETNDIMS($COMP(nd));
		$DOPRIVDIMS();
		$PRIV(offs) = $COMP(offset);
		for (i=0;i<$CHILD(ndims);i++) {
			$PRIV(incs)[i] = $COMP(sincs)[i];
			$CHILD(dims)[i] = $COMP(sdims)[i];
		}
		$SETDIMS();
		',
	Doc => undef,
);

pp_def(
	'diagonalI',
	P2Child => 1,
	DefaultFlow => 1,
	Reversible => 1,
	AffinePriv => 1,
	OtherPars => 'SV *list',
	Comp => 'int nwhichdims; PDL_Long whichdims[$COMP(nwhichdims)];',
	MakeComp => '
		int i,j;
		PDL_Long *tmp= PDL->packdims(list,&($COMP(nwhichdims)));
		if($COMP(nwhichdims) < 1) {
			$CROAK("Diagonal: must have at least 1 dimension");
		}
		$DOCOMPDIMS();
		for(i=0; i<$COMP(nwhichdims); i++)
			$COMP(whichdims)[i] = tmp[i];
		qsort($COMP(whichdims), $COMP(nwhichdims), sizeof(PDL_Long),
			cmp_pdll);
	',
	RedoDims => '
		int nthp,nthc,nthd; int cd = $COMP(whichdims[0]);
		$SETNDIMS($PARENT(ndims)-$COMP(nwhichdims)+1);
		$DOPRIVDIMS();
		$PRIV(offs) = 0;
		if ($COMP(whichdims)[$COMP(nwhichdims)-1] >= $PARENT(ndims) ||
			$COMP(whichdims)[0] < 0)
			$CROAK("Diagonal: dim out of range");
		nthd=0; nthc=0;
		for(nthp=0; nthp<$PARENT(ndims); nthp++)
			if (nthd < $COMP(nwhichdims) &&
			    nthp == $COMP(whichdims)[nthd]) {
				if (!nthd) {
					$CHILD(dims)[cd] = $PARENT(dims)[cd];
					nthc++;
					$PRIV(incs)[cd] = 0;
				}
				if (nthd && $COMP(whichdims)[nthd] ==
				    $COMP(whichdims)[nthd-1])
				       $CROAK("Diagonal: dims must be unique");
				nthd++; /* advance pointer into whichdims */
				if($CHILD(dims)[cd] !=
				    $PARENT(dims)[nthp]) {
					$CROAK("Different dims %d and %d",
						$CHILD(dims)[cd],
						$PARENT(dims)[nthp]);
				}
				$PRIV(incs)[cd] += $PARENT(dimincs)[nthp];
			} else {
				$PRIV(incs)[nthc] = $PARENT(dimincs)[nthp];
				$CHILD(dims)[nthc] = $PARENT(dims)[nthp];
				nthc++;
			}
		$SETDIMS();
	',
	Doc => << 'EOD',
=for ref

Returns the multidimensional diagonal over the specified dimensions.

The diagonal is placed at the first (by number) dimension that is
diagonalized.
The other diagonalized dimensions are removed. So if C<$a> has dimensions
C<(5,3,5,4,6,5)> then after

=for example

 $b = $a->diagonal(0,2,5);

the piddle C<$b> has dimensions C<(5,3,4,6)> and 
C<$b-E<gt>at(2,1,0,1)> refers
to C<$a-E<gt>at(2,1,2,0,1,2)>.

NOTE: diagonal doesn't handle threadids correctly. XXX FIX

EOD
);

pp_def(
	'lags',
	Doc => <<'EOD',
=for ref

Returns a piddle of lags to parent.

Usage:

=for usage

  $lags = $a->lags($nthdim,$step,$nlags);

I.e. if C<$a> contains

 [0,1,2,3,4,5,6,7]

then

=for example

 $b = $a->lags(0,2,2);

is a (5,2) matrix

 [2,3,4,5,6,7]
 [0,1,2,3,4,5]

This order of returned indices is kept because the function is
called "lags" i.e. the nth lag is n steps behind the original.

C<$step> and C<$nlags> must be positive. C<$nthdim> can be
negative and will then be counted from the last dim backwards
in the usual way (-1 = last dim).

EOD
	P2Child => 1,
	DefaultFlow => 1,
	Reversible => 1, # XXX Not really
	AffinePriv => 1,
	OtherPars => 'int nthdim; int step; int n;',
	RedoDims => '
		int i;
		if ($PRIV(nthdim) < 0)  /* the usual conventions */
	           $PRIV(nthdim) = $PARENT(ndims) + $PRIV(nthdim);
		if ($PRIV(nthdim) < 0 || $PRIV(nthdim) >= $PARENT(ndims))
		   $CROAK("lags: dim out of range");
		if ($COMP(n) < 1)
		   $CROAK("lags: number of lags must be positive");
		if ($COMP(step) < 1)
		   $CROAK("lags: step must be positive");
		$PRIV(offs) = 0;
		$SETNDIMS($PARENT(ndims)+1);
		$DOPRIVDIMS();
		for(i=0; i<$PRIV(nthdim); i++) {
			$CHILD(dims)[i] = $PARENT(dims)[i];
			$PRIV(incs)[i] = $PARENT(dimincs)[i];
		}
		$CHILD(dims)[i] = $PARENT(dims)[i] - $COMP(step) * ($COMP(n)-1);
		if ($CHILD(dims)[i] < 1)
		  $CROAK("lags: product of step size and "
			 "number of lags too large");
		$CHILD(dims)[i+1] = $COMP(n);
		$PRIV(incs)[i] = ($PARENT(dimincs)[i]);
		$PRIV(incs)[i+1] = - $PARENT(dimincs)[i] * $COMP(step);
                $PRIV(offs) += ($CHILD(dims)[i+1] - 1) * (-$PRIV(incs)[i+1]);
		i++;
		for(; i<$PARENT(ndims); i++) {
			$CHILD(dims)[i+1] = $PARENT(dims)[i];
			$PRIV(incs)[i+1] = $PARENT(dimincs)[i];
		}
		$SETDIMS();
	'
);

pp_def(
	'splitdim',
	Doc => <<'EOD',
=for ref

Splits a dimension in the parent piddle (opposite of L<clump|/clump>)

After

=for example

 $b = $a->splitdim(2,3);

the expression

 $b->at(6,4,x,y,3,6) == $a->at(6,4,x+3*y)

is always true (C<x> has to be less than 3).

EOD
	P2Child => 1,
	DefaultFlow => 1,
	Reversible => 1, # XXX Not really
	OtherPars => 'int nthdim; int nsp;',
	AffinePriv => 1,
	RedoDims => '
		int i = $COMP(nthdim);
		int nsp = $COMP(nsp);
		if(nsp == 0) {die("Splitdim: Cannot split to 0\n");}
		if(i <0 || i >= $PARENT(ndims)) {
			die("Splitdim: nthdim (%d) must not be negative or greater or equal to number of dims (%d)\n",
				i, $PARENT(ndims));
		}
		if(nsp > $PARENT(dims[i])) {
			die("Splitdim: nsp (%d) cannot be greater than dim (%d)\n",
				nsp, $PARENT(dims[i]));
		}
		$PRIV(offs) = 0;
		$SETNDIMS($PARENT(ndims)+1);
		$DOPRIVDIMS();
		for(i=0; i<$PRIV(nthdim); i++) {
			$CHILD(dims)[i] = $PARENT(dims)[i];
			$PRIV(incs)[i] = $PARENT(dimincs)[i];
		}
		$CHILD(dims)[i] = $COMP(nsp);
		$CHILD(dims)[i+1] = $PARENT(dims)[i] / $COMP(nsp);
		$PRIV(incs)[i] = $PARENT(dimincs)[i];
		$PRIV(incs)[i+1] = $PARENT(dimincs)[i] * $COMP(nsp);
		i++;
		for(; i<$PARENT(ndims); i++) {
			$CHILD(dims)[i+1] = $PARENT(dims)[i];
			$PRIV(incs)[i+1] = $PARENT(dimincs)[i];
		}
		$SETDIMS();
	',
);

pp_def('rotate',
	Doc => <<'EOD',
=for ref

Shift vector elements along with wrap. Flows data back&forth.

EOD
 	Pars=>'x(n); int shift(); [oca]y(n)',
        DefaultFlow => 1,
        Reversible => 1,
        Code=>'
        int i,j;
        int n_size = $SIZE(n);
	if (n_size == 0)
          barf("can not shift zero size piddle (n_size is zero)");
        j = ($shift()) % n_size;
        if (j < 0)
                j += n_size;
        for(i=0; i<n_size; i++,j++) {
            if (j == n_size)
               j = 0;
            $y(n=>j) = $x(n=>i);
        }',
        BackCode=>'
        int i,j;
        int n_size = $SIZE(n);
        j = ($shift()) % n_size;
        if (j < 0)
                j += n_size;
        for(i=0; i<n_size; i++,j++) {
            if (j == n_size)
               j = 0;
            $x(n=>i) = $y(n=>j);
        }
        '
);

# This is a bit tricky. Hope I haven't missed any cases.

pp_def(
	'threadI',
	Doc => <<'EOD',
=for ref

internal

Put some dimensions to a threadid.

=for example

 $b = $a->threadI(0,1,5); # thread over dims 1,5 in id 1

EOD
	P2Child => 1,
	DefaultFlow => 1,
	Reversible => 1,
	AffinePriv => 1,
	CallCopy => 0,  # Don't CallCopy for subclassed objects because PDL::Copy calls ThreadI
			#  (Wouldn't cause recursive loop otherwise)
	OtherPars => 'int id; SV *list',
	Comp => 'int id; int nwhichdims; PDL_Long whichdims[$COMP(nwhichdims)];
			int nrealwhichdims; ',
	MakeComp => '
		int i,j;
		PDL_Long *tmp= PDL->packdims(list,&($COMP(nwhichdims)));
		$DOCOMPDIMS();
		for(i=0; i<$COMP(nwhichdims); i++)
			$COMP(whichdims)[i] = tmp[i];
		$COMP(nrealwhichdims) = 0;
		for(i=0; i<$COMP(nwhichdims); i++) {
			for(j=i+1; j<$COMP(nwhichdims); j++)
				if($COMP(whichdims[i]) == $COMP(whichdims[j]) &&
				   $COMP(whichdims[i]) != -1) {
				$CROAK("Thread: duplicate arg %d %d %d",
					i,j,$COMP(whichdims[i]));
			}
			if($COMP(whichdims)[i] != -1) {
				$COMP(nrealwhichdims) ++;
			}
		}
		$COMP(id) = id;
		',
	RedoDims => '
		int nthc,i,j,flag;
		$SETNDIMS($PARENT(ndims));
		$DOPRIVDIMS();
		$PRIV(offs) = 0;
		nthc=0;
		for(i=0; i<$PARENT(ndims); i++) {
			flag=0;
			if($PARENT(nthreadids) > $COMP(id) &&
			   i == $PARENT(threadids[$COMP(id)])) {
			   nthc += $COMP(nwhichdims);
			}
			for(j=0; j<$COMP(nwhichdims); j++) {
				if($COMP(whichdims[j] == i)) {flag=1; break;}
			}
			if(flag) {
				continue;
			}
			$CHILD(dims[nthc]) = $PARENT(dims[i]);
			$PRIV(incs[nthc]) = $PARENT(dimincs[i]);
			nthc++;
		}
		for(i=0; i<$COMP(nwhichdims); i++) {
			int cdim,pdim;
			cdim = i +
			 ($PARENT(nthreadids) > $COMP(id) ?
			  $PARENT(threadids[$COMP(id)]) : $PARENT(ndims))
			  - $COMP(nrealwhichdims);
			pdim = $COMP(whichdims[i]);
			if(pdim == -1) {
				$CHILD(dims[cdim]) = 1;
				$PRIV(incs[cdim]) = 0;
			} else {
				$CHILD(dims[cdim]) = $PARENT(dims[pdim]);
				$PRIV(incs[cdim]) = $PARENT(dimincs[pdim]);
			}
		}
		$SETDIMS();
		PDL->reallocthreadids($CHILD_PTR(),
			($PARENT(nthreadids)<=$COMP(id) ?
				$COMP(id)+1 : $PARENT(nthreadids)));
		for(i=0; i<$CHILD(nthreadids); i++) {
			$CHILD(threadids[i]) =
			 ($PARENT(nthreadids) > i ?
			  $PARENT(threadids[i]) : $PARENT(ndims)) +
			 (i <= $COMP(id) ? - $COMP(nrealwhichdims) :
			  $COMP(nwhichdims) - $COMP(nrealwhichdims));
		}
		$CHILD(threadids[$CHILD(nthreadids)]) = $CHILD(ndims);
		',
);


# we don't really need this one since it can be achieved with
# a ->threadI(-1,[])
pp_def('identvaff',
	P2Child => 1,
	DefaultFlow => 1,
	Reversible => 1,
	AffinePriv => 1,
	RedoDims => '
		int i;
		$SETNDIMS($PARENT(ndims));
		$DOPRIVDIMS();
		$PRIV(offs) = 0;
		for(i=0; i<$PARENT(ndims); i++) {
			$CHILD(dims[i]) = $PARENT(dims[i]);
			$PRIV(incs[i]) = $PARENT(dimincs[i]);
		}
		$SETDIMS();
		$SETDELTATHREADIDS(0);
		$CHILD(threadids[$CHILD(nthreadids)]) = $CHILD(ndims);
		',
	Doc => <<'EOD',
=for ref

A vaffine identity transformation (includes thread_id copying).

Mainly for internal use.

EOD
);


pp_def(
	'unthread',
	Doc => <<'EOD',
=for ref

All threaded dimensions are made real again.

See [TBD Doc] for details and examples.

EOD
	P2Child => 1,
	DefaultFlow => 1,
	Reversible => 1,
	AffinePriv => 1,
	OtherPars => 'int atind;',
	RedoDims => '
		int i;
		$SETNDIMS($PARENT(ndims));
		$DOPRIVDIMS();
		$PRIV(offs) = 0;
		for(i=0; i<$PARENT(ndims); i++) {
			int corc;
			if(i<$COMP(atind)) {
				corc = i;
			} else if(i < $PARENT(threadids[0])) {
				corc = i + $PARENT(ndims)-$PARENT(threadids[0]);
			} else {
				corc = i - $PARENT(threadids[0]) + $COMP(atind);
			}
			$CHILD(dims[corc]) = $PARENT(dims[i]);
			$PRIV(incs[corc]) = $PARENT(dimincs[i]);
		}
		$SETDIMS();
	',
);


pp_add_exported('', 'dice dice_axis');
pp_addpm(<<'EOD');

=head2 dice

=for ref

Dice rows/columns/planes out of a PDL using indexes for
each dimension.

This function can be used to extract irregular subsets
along many dimension of a PDL, e.g. only certain rows in an image,
or planes in a cube. This can of course be done with
the usual dimension tricks but this saves having to
figure it out each time!

This method is similar in functionality to the L<slice|/slice>
method, but L<slice|/slice> requires that contiguous ranges or ranges
with constant offset be extracted. ( i.e. L<slice|/slice> requires 
ranges of the form C<1,2,3,4,5> or C<2,4,6,8,10>). Because of this
restriction, L<slice|/slice> is more memory efficient and slightly faster
than dice

=for usage

 $slice = $data->dice([0,2,6],[2,1,6]); # Dicing a 2-D array

The arguments to dice are arrays (or 1D PDLs) for each dimension
in the PDL. These arrays are used as indexes to which rows/columns/cubes,etc
to dice-out (or extract) from the C<$data> PDL. 

Use C<X> to select all indices along a given dimension (compare also
L<mslice|PDL::Core/mslice>). As usual (in slicing methods) trailing
dimensions can be omitted implying C<X>'es for those.

=for example 

 perldl> $a = sequence(10,4)
 perldl> p $a
 [
  [ 0  1  2  3  4  5  6  7  8  9]
  [10 11 12 13 14 15 16 17 18 19]
  [20 21 22 23 24 25 26 27 28 29]
  [30 31 32 33 34 35 36 37 38 39]
 ]
 perldl> p $a->dice([1,2],[0,3]) # Select columns 1,2 and rows 0,3
 [
  [ 1  2]
  [31 32]
 ]
 perldl> p $a->dice(X,[0,3])
 [
  [ 0  1  2  3  4  5  6  7  8  9]
  [30 31 32 33 34 35 36 37 38 39]
 ]
 perldl> p $a->dice([0,2,5])
 [
  [ 0  2  5]
  [10 12 15]
  [20 22 25]
  [30 32 35]
 ]

As this is an index function, any modifications to the
slice change the parent (use the C<.=> operator).

=cut

sub PDL::dice { 

	my $self = shift;
	my @dim_indexes = @_;  # array of dimension indexes
	
	# Check that the number of dim indexes <=
	#    number of dimensions in the PDL
	my $no_indexes = scalar(@dim_indexes);
	my $noDims = $self->getndims;
	barf("PDL::dice: Number of index arrays ($no_indexes) not equal to the dimensions of the PDL ($noDims")
			 if $no_indexes > $noDims;
	my $index;
	my $pdlIndex;
	my $outputPDL=$self;
	my $indexNo = 0;

	# Go thru each index array and dice the input PDL:
	foreach $index(@dim_indexes){

		$outputPDL = $outputPDL->dice_axis($indexNo,$index)
			unless !ref $index && $index eq 'X';

		$indexNo++;
	}

	return $outputPDL;
}  
*dice = \&PDL::dice;


=head2 dice_axis

=for ref

Dice rows/columns/planes from a single PDL axis (dimension)
using index along a specified axis

This function can be used to extract irregular subsets
along any dimension, e.g. only certain rows in an image,
or planes in a cube. This can of course be done with
the usual dimension tricks but this saves having to
figure it out each time!

=for usage

 $slice = $data->dice_axis($axis,$index);

=for example

 perldl> $a = sequence(10,4)
 perldl> $idx = pdl(1,2)
 perldl> p $a->dice_axis(0,$idx) # Select columns
 [
  [ 1  2]
  [11 12]
  [21 22]
  [31 32]
 ]
 perldl> $t = $a->dice_axis(1,$idx) # Select rows
 perldl> $t.=0
 perldl> p $a
 [
  [ 0  1  2  3  4  5  6  7  8  9]
  [ 0  0  0  0  0  0  0  0  0  0]
  [ 0  0  0  0  0  0  0  0  0  0]
  [30 31 32 33 34 35 36 37 38 39]
 ]

The trick to using this is that the index selects
elements along the dimensions specified, so if you
have a 2D image C<axis=0> will select certain C<X> values
- i.e. extract columns

As this is an index function, any modifications to the
slice change the parent.

=cut

sub PDL::dice_axis { 
  my($self,$axis,$idx) = @_;
  
  # Convert to PDLs: array refs using new, otherwise use topdl:
  my $ix = (ref($idx) eq 'ARRAY') ? ref($self)->new($idx) : ref($self)->topdl($idx);
  my $n = $self->getndims;
  my $a = $ix->getndims;
  barf("index_axis: index must be <=1D") if $a>1;
  for ($a..$n-1) {
     $ix = $ix->dummy(0);
  }
  return $self->mv($axis,0)->index($ix)->mv($n-1,$axis);
}  
*dice_axis = \&PDL::dice_axis;


EOD

pp_done();
__DATA__

# A very useful transformation for e.g. axis values: hexagonal
# arrays can be made like this.

if(0) {
deftrans(
	Name => 'repeat',
	Pars => 'int whichind, int howmany',
	MakeComp => '
		$COMP(howmany) = howmany;
		$COMP(whichind) = whichind;
		$SETREVERSIBLE($COMP(howmany)==1);
		',
	Dims => '
		$SETNDIMS($PARENT(ndims));
		LOOPDIMS %{
			$CHILD(dims[$DIM]) = $PARENT(dims[$DIM]);
		%}
		$CHILD(dims[$COMP(whichind)]) *= $PRIV(howmany);
		$SETDIMS();
		',
	ParentInds =>
		'$COPYINDS();
		 $PARENTINDS($COMP(whichind)) %= $PARENT(dims[$PRIV(whichind)]);',
	Print => 'printf("REPEAT: %d, %d\n",
			$COMP(whichind), $COMP(howmany));'
);
}

# Parent's first index is value of indices.

if(0) {
deftrans(
	Name => 'indexed',
	Pars => 'pdl* indices',
	Dims => '
		$SETNDIMS($COMP(indices)->ndims);
		LOOPDIMS %{
			$CHILD(dims[$DIM]) = $COMP(indices)->dims[$DIM];
		%}
		',
	ParentInds =>
		'$COPYINDS();
		 $PARENTINDS(0) = PDL->get($COMP(indices),&($MYINDS(0)));'
);
}


