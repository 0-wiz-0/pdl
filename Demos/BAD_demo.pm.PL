#
# Create BAD_demo.pm
# - needed since we allow bad pixel handling to be switched off
#
 
use strict;
 
use Config;
use File::Basename qw(&basename &dirname);
 
# check for bad value support
use File::Spec;
require File::Spec->catfile( File::Spec->updir, "perldl.conf" );
use vars qw( %PDL_CONFIG );
my $bvalflag = $PDL_CONFIG{WITH_BADVAL} || 0;
 
# This forces PL files to create target in same directory as PL file.
# This is so that make depend always knows where to find PL derivatives.
chdir(dirname($0));
my $file;
($file = basename($0)) =~ s/\.PL$//;
$file =~ s/\.pl$//
        if ($Config{'osname'} eq 'VMS' or
            $Config{'osname'} eq 'OS2');  # "case-forgiving"
open OUT,">$file" or die "Can't create $file: $!";
 
if ( $bvalflag ) {
    print "Extracting $file (WITH bad value support)\n";
} else {
    print "Extracting $file (NO bad value support)\n";
}
chmod 0644, $file;
 
print OUT <<'!NO!SUBS!';
#
# Created by BAD_demo.pm.PL
#  ** DO NOT EDIT THIS FILE **
#
package PDL::Demos::BAD_demo;
use PDL;

PDL::Demos::Routines->import();
sub comment($);
sub act($);
sub output;

sub run {

!NO!SUBS!

    if ( ! $bvalflag ) {
	print OUT <<'!NO!SUBS!';

comment q|
    Your version of PDL has been compiled without support for bad
    values, hence this demo doesn't do very much.

|;

!NO!SUBS!

} else {
    print OUT <<'!NO!SUBS!';

comment q|
    Welcome to this tour of the bad value support in PDL

    This is currently a 'work in progress', so please excuse the mess.

    Each piddle contains a flag - accessible via the badflag() method - 
    which indicates whether:

       the piddle contains no bad values (flag equals 0)
       the piddle *MAY* contain bad values (flag equals 1)

    If the flag is set, then the routines (well, those that have been
    converted) will process these bad values correctly, otherwise they 
    are ignored. 

    The code has been written so as to provide as little overhead as
    possible; therefore there should be almost no difference in the
    time it takes to process piddles which do not have their bad flag 
    set.

|;

act q|
    # check to see whether bad value support has been compiled in
    croak("Oh, no bad value support!\n") unless $PDL::Bad::Status;
|;

act q|
    # create a piddle
    $a = byte(1,2,3);
    print( "Bad flag (a) == ", $a->badflag(), "\n" );
    # set bad flag, even though all the data is good
    $a->badflag(1);
    print( "Bad flag (a) == ", $a->badflag(), "\n" );
    # note the bad flag is infectious
    $b = 2 * $a;
    print( "Bad flag (b) == ", $b->badflag(), "\n" );
|;

act q|
    print "No bad values:   ", $a, "\n";
    # set the middle value bad
    set($a,1,$a->badvalue());
    # now print out
    print "Some bad values: ", $a, "\n";
|;

=begin COMMENT

act q|
    # First we define some variables to use for the rest of the demo.
    $x=sequence(10);
    $y=2*$x**2;

    # Now a simple plot with points
    points $x, $y;
|;

act q|
    # Here is the same with lines
    line $x, $y;
|;

act q|
    # If you want to overlay one plot you can use the command
    # 'hold' to put the graphics on hold and 'release' to
    # revert the effect

    points $x, $y, {SYMBOL=>4};  # The last argument sets symboltype
    hold;
    # Now draw lines between the points
    line $x, $y;
    # Plot errorbars over the points
    $yerr=sqrt($y);
    errb $x, $y, $yerr;

    # To revert to old behaviour, use release
    release;
|;

act q|
    bin $x, $y;

    # This plots a binned histogram of the data and as you can
    # see it made a new plot.
|;

act q|
    # 2D data can also easily be accomodated:

    # First make a simple image
    $gradient=sequence(40,40);

    # Then display it.
    imag $gradient;

    # And overlay a contour plot over it:
    hold;
    cont $gradient;
    release;
|;

act q|
  # PDL::Graphics::PGPLOT contains several colour tables,
  # a more extensive collection can be found in 
  # PDL::Graphics::LUT
  #
  # (note: the call to lut_names() can take a few seconds to execute)
  #
  use PDL::Graphics::LUT;
  @names = lut_names();
  print "Available tables: [ ", @names, " ]\n";

  # use the first table
  ctab( lut_data($names[0]) );
  use PGPLOT;
  pglabel "", "", "Colour table: $names[0]";

|;

act q|
    # To change plot specifics you can either use the specific PGPLOT
    # commands - recommended if you need lots of control over your
    # plot.
    #
    # Or you can use the new option specifications:

    # To plot our first graph again with blue color, dashed line
    # and a thickness of 10 we can do:

    line $x, $y, {COLOR=>5, LINESTYLE=>'dashed', LINEWIDTH=>10};

|;

act q|

  # Now for a more complicated example.
  # First create some data
  $a=sequence(360)*3.1415/180.;
  $b=sin($a)*transpose(cos($a));

  # Make a piddle with the wanted contours
  $contours=pdl [0.1,0.5,1.0];
  # And an array (reference to an array) with labels
  $labels=['A', 'B', 'C'];
  # Create a contour map of the data - note that we can set the colour of
  # the labels.
  cont($b, {CONTOURS=>$contours, linest=>'DASHED',
	    LINEWIDTH=>3, COLOR=>2, LABELCOL=>4});
  hold;

  pgqlw($linewidth);

  points $a->slice('0:-1:4')*180./3.1415;
  release;
|;

act q|
  #
  # More examples of changing the plot defaults
  # 
  $a = 1+sequence(10);
  $b = $a*2;
  $bord_opt = { TYPE => 'RELATIVE', VALUE => 0.1 };
  line log10($a), $b, { AXIS => 'LOGX', BORDER => $bord_opt };
|;

act q|
  #
  # We can also create vector maps of data
  # This requires one array for the horizontal component and
  # one for the vertical component
  #
  $horizontal=sequence(10,10);
  $vertical=transpose($horizontal)+random(10,10)*$horizontal/10.;

  $arrow={ARROW=> {FS=>1, ANGLE=>25, VENT=>0.7, SIZE=>3}};
  vect $horizontal, $vertical, {ARROW=>$arrow, COLOR=>RED};
  hold;
  cont $vertical-$horizontal, {COLOR=>YELLOW};
  release;

|;

act q|
  #
  # To draw [filled] polygons, the command poly is handy:
  #

  $x=sequence(10)/5;
  poly $x, $x**2, {FILL=>HATCHED, COLOR=>BLUE};

|;

act q|
  #
  # the latest feature of PDL are complex numbers
  # so let's play with a simple example
  #
  

  use PDL::Complex;
  $z50 = zeroes(50);
  $c = $z50->xlinvals(0,7)+i*$z50->xlinvals(2,4);
  line im sin $c; hold;      # the imaginary part
  line re sin $c;            # real
  line abs sin $c; release;  # and the modulus
  
|;

act q|
  #
  # more complex numbers
  #
  
  use PDL::Complex;
  $c =  zeroes(300)->xlinvals(0,12)+i*zeroes(300)->xlinvals(2,10);
  $sin = sin $c;
  line $sin->im, $sin->re;   # look at the result in the complex plane
  
|;

=end COMMENT

=cut

!NO!SUBS!

} # if: $bvalflag

print OUT <<'!NO!SUBS!';

}

1;

!NO!SUBS!

# end
