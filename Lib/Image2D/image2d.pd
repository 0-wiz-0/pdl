use strict;

pp_addpm({At=>'Top'},<<'EOD');

=head1 NAME

PDL::Image2D - Miscellaneous 2D image processing functions

=head1 DESCRIPTION

Miscellaneous 2D image processing functions - for want
of anywhere else to put them

=head1 SYNOPSIS

 use PDL::Image2D;

=cut

use PDL::Ufunc;  # ensure qsort routine available
use Carp;

EOD

pp_addpm({At=>'Bot'},<<'EOD');

=head1 AUTHORS

Copyright (C) Karl Glazebrook 1997 with additions by Robin Williams
(rjrw@ast.leeds.ac.uk) and Tim Jeness (timj@jach.hawaii.edu).
All rights reserved. There is no warranty. You are allowed
to redistribute this software / documentation under certain
conditions. For details, see the file COPYING in the PDL
distribution. If this file is separated from the PDL distribution,
the copyright notice should be included in the file.

=cut

EOD

pp_addhdr('

#define IsNaN(x) (x != x)

/* Fast Modulus with proper negative behaviour */

#define REALMOD(a,b) {while ((a)>=(b)) (a) -= (b); while ((a)<0) (a) += (b);}

/* rint is missing on some platforms (eg Win32) */

#ifdef NEEDS_RINT
#define rint(X) floor( X + 0.5 )
#endif

');

my %init = 
    ( 
      i => { size => 'm_size', off => 'poff', init => '1-p_size' },
      j => { size => 'n_size', off => 'qoff', init => '1-q_size' },
      );
	     
# requires 'int $var, ${var}2' to have been declared in the c code
# (along with [pq]off and [pq]_size)
#
sub init_map {
    my $var = shift;

    my $loop = $var;
    my $loop2 = "${var}2";

    my $href = $init{$var} ||
	die "ERROR: unknown variable sent to init_map()\n";
    my $size = $href->{size} || 
	die "ERROR: unable to find size for $var\n";
    my $off  = $href->{off} || 
	die "ERROR: unable to find off for $var\n";
    my $init = $href->{init} || 
	die "ERROR: unable to find init for $var\n";

    return
"for ( $loop = $init; $loop< $size; ${loop}++) {
    $loop2 = $loop + $off;
    switch (opt) {
       case 1:      /* REFLECT */
          if (${loop2}<0)
             $loop2 = -${loop2}-1;
          else if ($loop2 >= $size)
             $loop2 = 2*${size}-(${loop2}+1);
          break;
       case 2:      /* TRUNCATE */
          if (${loop2}<0 || ${loop2} >= $size)
             $loop2 = -1;
          break;
       default:
           REALMOD($loop2,$size);
    }
    map${var}\[$loop] = $loop2;
 }\n";
   
} # sub: init_map()

sub init_vars {
    my $href = shift || { };
    $href->{vars}   = '' unless defined $href->{vars};
    $href->{malloc} = '' unless defined $href->{malloc};
    $href->{check}  = '' unless defined $href->{check};

    my $str = $href->{vars};
    $str .= "int i,j, i1,j1, i2,j2, poff, qoff;";
    $str .=
	'int opt = $COMP(opt);
         int m_size = $COMP(__m_size);
         int n_size = $COMP(__n_size);
         int p_size = $COMP(__p_size);
         int q_size = $COMP(__q_size);
         int *mapi, *mapj;
	 
         mapi = (int *) malloc((p_size+m_size)*sizeof(int));
         mapj = (int *) malloc((q_size+n_size)*sizeof(int));
	 ';
    $str .= $href->{malloc} . "\n";
    $str .= "if ($href->{check} (mapi==NULL) || (mapj==NULL))\n";
    $str .= '  barf("Out of Memory");
	 
         poff = p_size/2; mapi += p_size-1;
         qoff = q_size/2; mapj += q_size-1;
';

    return $str;
} # sub: init_vars()

pp_def('conv2d', Doc=><<'EOD',
=for ref

2D convolution of an array with a kernel (smoothing)

For large kernels, using a FFT routine,
such as L<PDL::FFT::fftconvolve()|PDL::FFT/fftconvolve>,
will be quicker.

=for usage

 $new = conv2d $old, $kernel, {OPTIONS}

=for example

 $smoothed = conv2d $image, ones(3,3), {Boundary => Reflect}

=for options

 Boundary - controls what values are assumed for the image when kernel
            crosses its edge:
 	    => Default  - periodic boundary conditions 
                          (i.e. wrap around axis)
 	    => Reflect  - reflect at boundary
 	    => Truncate - truncate at boundary

EOD
       BadDoc =>
'Unlike the FFT routines, conv2d is able to process bad values.',
       HandleBad => 1,
        Pars => 'a(m,n); kern(p,q); [o]b(m,n);',
        OtherPars => 'int opt;',
        PMCode => '

sub PDL::conv2d {
   my $opt; $opt = pop @_ if ref($_[$#_]) eq \'HASH\';
   die \'Usage: conv2d( a(m,n), kern(p,q), [o]b(m,n), {Options} )\'
      if $#_<1 || $#_>2;
   my($a,$kern) = @_;
   my $c = $#_ == 2 ? $_[2] : PDL->null;
   &PDL::_conv2d_int($a,$kern,$c,
	(!(defined $opt && exists $$opt{Boundary}))?0:
	(($$opt{Boundary} eq "Reflect") +
	2*($$opt{Boundary} eq "Truncate")));
   return $c;
}

',
        Code => 
           init_vars( { vars => 'PDL_Double tmp;' } ) .
           init_map("i") . 
           init_map("j") .
'
           threadloop %{
           for(j=0; j<n_size; j++) { 
              for(i=0; i<m_size; i++) {
                 tmp = 0;
                 for(j1=0; j1<q_size; j1++) {
                    j2 = mapj[j-j1];

                    if (j2 >= 0) {
                       for(i1=0; i1<p_size; i1++) {
                          i2 = mapi[i-i1];
                          if (i2 >= 0)
                             tmp += $a(m=>i2,n=>j2) * $kern(p=>i1,q=>j1);
		       } /* for: i1 */
		    } /* if: j2 >= 0 */
		 } /* for: j1 */
                 $b(m=>i,n=>j) = tmp;
	      } /* for: i */
           } /* for: j */ 
           %}
	   free(mapj+1-q_size); free(mapi+1-p_size);',
        BadCode => 
           init_vars( { vars => 'PDL_Double tmp; int flag;' } ) .
           init_map("i") . 
           init_map("j") .
'
           threadloop %{
           for(j=0; j<n_size; j++) { 
              for(i=0; i<m_size; i++) {
                 tmp = 0;
                 for(j1=0; j1<q_size; j1++) {
                    j2 = mapj[j-j1];

                    if (j2 >= 0) {
                       for(i1=0; i1<p_size; i1++) {
                          i2 = mapi[i-i1];
                          if (i2 >= 0) {
			     if ( $ISGOOD(a(m=>i2,n=>j2)) && $ISGOOD(kern(p=>i1,q=>j1)) ) {
                                tmp += $a(m=>i2,n=>j2) * $kern(p=>i1,q=>j1);
                                flag = 1;
			     } /* if: good */
                          } /* if: i2 >= 0 */
		       } /* for: i1 */
		    } /* if: j2 >= 0 */
		 } /* for: j1 */
		 if ( flag ) { $b(m=>i,n=>j) = tmp; }
		 else        { $SETBAD(b(m=>i,n=>j)); }
	      } /* for: i */
           } /* for: j */
           %}
	   free(mapj+1-q_size); free(mapi+1-p_size);',

); # pp_def: conv2d

pp_def('med2d', Doc=> <<'EOD',
=for ref

2D median-convolution of an array with a kernel (smoothing)

Note: only points in the kernel E<gt>0 are included in the median, other
points are weighted by the kernel value (medianing lots of zeroes
is rather pointless)

=for usage

 $new = med2d $old, $kernel, {OPTIONS}

=for example

 $smoothed = med2d $image, ones(3,3), {Boundary => Reflect}

=for options

 Boundary - controls what values are assumed for the image when kernel
            crosses its edge:
 	    => Default  - periodic boundary conditions (i.e. wrap around axis)
 	    => Reflect  - reflect at boundary
 	    => Truncate - truncate at boundary

EOD
       BadDoc => 
'Bad values are ignored in the calculation. If all elements within the 
kernel are bad, the output is set bad.',
       HandleBad => 1,
        Pars => 'a(m,n); kern(p,q); [o]b(m,n);',
        OtherPars => 'int opt;',
        PMCode => '

sub PDL::med2d {
   my $opt; $opt = pop @_ if ref($_[$#_]) eq \'HASH\';
   die \'Usage: med2d( a(m,n), kern(p,q), [o]b(m,n), {Options} )\'
      if $#_<1 || $#_>2;
   my($a,$kern) = @_;
   croak "med2d: kernel must contain some positive elements.\n" 
       if all( $kern <= 0 );
   my $c = $#_ == 2 ? $_[2] : PDL->null;
   &PDL::_med2d_int($a,$kern,$c,
	(!(defined $opt && exists $opt->{Boundary}))?0:
	(($$opt{Boundary} eq "Reflect") +
	2*($$opt{Boundary} eq "Truncate")));
   return $c;
}

',
        Code => 
           init_vars( { vars => 'PDL_Double *tmp, kk; int count;',
                        malloc => 'tmp = malloc(p_size*q_size*sizeof(PDL_Double));',
                        check => '(tmp==NULL) || ' } ) .
           init_map("i") . 
           init_map("j") .
'
           threadloop %{
           for(j=0; j<n_size; j++) { 
              for(i=0; i<m_size; i++) {
                 count = 0;
                 for(j1=0; j1<q_size; j1++) {
                    j2 = mapj[j-j1];

                    if (j2 >= 0)
                       for(i1=0; i1<p_size; i1++) {
                          i2 = mapi[i-i1];
                          if (i2 >= 0) {
                             kk = $kern(p=>i1,q=>j1);
                             if (kk>0) {
                                tmp[count++] = $a(m=>i2,n=>j2) * kk;
                             }
                          } /* if: i2 >= 0 */
		       } /* for: i1 */
		 } /* for: j1 */

                 PDL->qsort_D( tmp, 0, count-1 );
                 $b(m=>i,n=>j) = tmp[(count-1)/2];

              } /* for: i */
           } /* for: j */
           %}
           free(mapj+1-q_size); free(mapi+1-p_size); free(tmp);
',
        BadCode => 
           init_vars( { vars => 'PDL_Double *tmp, kk, aa; int count, flag;',
                        malloc => 'tmp = malloc(p_size*q_size*sizeof(PDL_Double));',
                        check => '(tmp==NULL) || ' } ) .
           init_map("i") . 
           init_map("j") .
'
           threadloop %{
           for(j=0; j<n_size; j++) { 
              for(i=0; i<m_size; i++) {
                 count = 0;
                 flag = 0;
                 for(j1=0; j1<q_size; j1++) {
                    j2 = mapj[j-j1];

                    if (j2 >= 0)
                       for(i1=0; i1<p_size; i1++) {
                          i2 = mapi[i-i1];
                          if (i2 >= 0) {
                             kk = $kern(p=>i1,q=>j1);
                             aa = $a(m=>i2,n=>j2);
                             if ( $ISGOODVAR(kk,kern) && $ISGOODVAR(aa,a) ) {
				flag = 1;
                                if ( kk > 0 ) {
                                   tmp[count++] = aa * kk;
			        }
                             }
                          } /* if: i2 >= 0 */
		       } /* for: i1 */
		 } /* for: j1 */
		 if ( flag == 0 ) {
		    $SETBAD(b(m=>i,n=>j));
                 } else {

                    PDL->qsort_D( tmp, 0, count-1 );
                    $b(m=>i,n=>j) = tmp[(count-1)/2];

		 }
              } /* for: i */
           } /* for: j */
           %}
           free(mapj+1-q_size); free(mapi+1-p_size); free(tmp);
'

); # pp_def: med2d

pp_def('patch2d', 
       Doc=><<'EOD',
=for ref

patch bad pixels out of 2D images using a mask

=for usage

 $patched = patch2d $data, $bad;

C<$bad> is a 2D mask array where 1=bad pixel 0=good pixel. 
Pixels are replaced by the average of their non-bad neighbours;
if all neighbours are bad, the original data value is
copied across.

EOD
       BadDoc => 
'This routine does not handle bad values - use L<patchbad2d|/patchbad2d> instead',
       HandleBad => 0,
        Pars => 'a(m,n); int bad(m,n); [o]b(m,n);',
        Code => 
        'int m_size, n_size,  i,j, i1,j1, i2,j2, norm;
         double tmp;
	 
         m_size = $COMP(__m_size); n_size = $COMP(__n_size);

      threadloop %{
	 
         for(j=0; j<n_size; j++) { 
            for(i=0; i<m_size; i++) {

               $b(m=>i,n=>j) = $a(m=>i,n=>j);

               if ( $bad(m=>i,n=>j)==1 ) {
                  tmp = 0; norm=0;
                  for(j1=-1; j1<=1; j1++) { 
		     j2 = j+j1;
		     if ( j2>=0 && j2<n_size ) {
                        for(i1=-1; i1<=1; i1++) {
                           /* ignore central pixel, which we know is bad */
			   if ( i1!=0 || j1!=0 ) {
                              i2 = i+i1; 
                              if ( i2>=0 && i2<m_size && $bad(m=>i2,n=>j2)!=1 ) {
                                 tmp += $a(m=>i2,n=>j2); 
                                 norm++;
			      }
			   } /* if: i1!=0 || j1!=0 */
		        } /* for: i1 */
		     }
		  } /* for: j1 */

                  if (norm>0) {  /* Patch */
                     $b(m=>i,n=>j) = tmp/norm;
		  }
	 
               } /* if: bad() */

	    } /* for: i */
         } /* for: j */

      %} /* threadloop */

         ', # Code
);

pp_def('patchbad2d', 
       Doc=><<'EOD',
=for ref

patch bad pixels out of 2D images containing bad values

=for usage

 $patched = patchbad2d $data;

Pixels are replaced by the average of their non-bad neighbours;
if all neighbours are bad, the output is set bad.
If the input piddle contains I<no> bad values, then a straight copy
is performed (see L<patch2d|/patch2d>).

EOD
       BadDoc => 
'patchbad2d handles bad values. The output piddle I<may> contain
bad values, depending on the pattern of bad values in the input piddle.',
       HandleBad => 1,
        Pars => 'a(m,n); [o]b(m,n);',
        Code => 'loop(n,m) %{ $b() = $a(); %}', # just copy
        CopyBadStatusCode => '', # handled by BadCode
        BadCode => 
        'int m_size, n_size,  i,j, i1,j1, i2,j2, norm, flag;
         double tmp;
         $GENERIC(a) a_val;

         flag = 0;
         m_size = $COMP(__m_size); n_size = $COMP(__n_size);

      threadloop %{
	 
         for(j=0; j<n_size; j++) { 
            for(i=0; i<m_size; i++) {

	       a_val = $a(m=>i,n=>j);	
               if ( $ISGOODVAR(a_val,a) ) {
                  $b(m=>i,n=>j) = a_val;

	       } else { 
                  tmp = 0; norm=0;
                  for(j1=-1; j1<=1; j1++) { 
		     j2 = j+j1;
		     if ( j2>=0 && j2<n_size ) {
                        for(i1=-1; i1<=1; i1++) {
                           /* ignore central pixel, which we know is bad */
			   if ( i1!=0 || j1!=0 ) {
                              i2 = i+i1; 
                              if ( i2>=0 && i2<m_size ) {
                                 a_val = $a(m=>i2,n=>j2);
                                 if ( $ISGOODVAR(a_val,a) ) {
                                    tmp += a_val; 
                                    norm++;
				 }
			      }
			   } /* if: i1!=0 || j1!=0 */
		        } /* for: i1 */
		     }
		  } /* for: j1 */

                  /* Patch */
                  if (norm>0) {
                     $b(m=>i,n=>j) = tmp/norm;
		  } else {
		     $SETBAD(b(m=>i,n=>j));
                     flag = 1;
                  }
	 
               } /* if: ISGOODVAR() */

	    } /* for: i */
         } /* for: j */

      %} /* threadloop */
 
         /* handle bad flag */
         if ( flag ) $PDLSTATESETBAD(b);
         ', # BadCode
);

pp_def('max2d_ind',Doc=><<'EOD',
=for ref

Return value/position of maximum value in 2D image

Contributed by Tim Jeness

EOD

       HandleBad => 0, # a marker
        Pars => 'a(m,n); [o]val(); int [o]x(); int[o]y();',
        Code => '
        double cur; int curind1; int curind2;
        curind1=0;
        curind2=0;
        loop(m) %{
           loop(n) %{
           if((!m && !n) || $a() > cur || IsNaN(cur)) {
                cur = $a(); curind1 = m; curind2 = n;
              }
           %}
        %}
        $val() = cur;
        $x()   = curind1;
        $y()   = curind2;
        ');

pp_def('centroid2d',Doc=><<'EOD',
=for ref

Refine a list of object positions in 2D image by centroiding in a box

C<$box> is the full-width of the box, i.e. the window
is C<+/- $box/2>.

EOD
       HandleBad => 0, # a marker
	Pars => 'im(m,n); x(); y(); box(); [o]xcen(); [o]ycen();',
	Code => '
   int i,j,i1,i2,j1,j2,m_size,n_size;
   double sum,data,sumx,sumy;

   m_size = $SIZE(m); n_size = $SIZE(n);

   i1 = $x() - $box()/2; i1 = i1<0 ? 0 : i1;
   i2 = $x() + $box()/2; i1 = i1>=m_size ? m_size-1 : i1;
   j1 = $y() - $box()/2; j1 = j1<0 ? 0 : j1;
   j2 = $y() + $box()/2; j1 = j1>=n_size ? n_size-1 : j1;

   sum = sumx = sumy = 0;
   for(j=j1; j<=j2; j++) { for(i=i1; i<=i2; i++) {
      data = $im(m=>i,n=>j);
      sum += data;
      sumx += data*i;
      sumy += data*j;
   }}
   $xcen() = sumx/sum;
   $ycen() = sumy/sum;
'
);

pp_addhdr('

/* Add an equivalence to a list - used by pdl_cc8compt */

void AddEquiv ( PDL_Long* equiv, PDL_Long i, PDL_Long j) {

   PDL_Long k, tmp;

   if (i==j)
      return;

    k = j;
    do {
      k = equiv[k];
    } while ( k != j && k != i );

    if ( k == j ) {
       tmp = equiv[i];
       equiv[i] = equiv[j];
       equiv[j] = tmp;
    }
}

');


pp_def('cc8compt',Doc=>'
=for ref

Connected 8-component labeling of a binary image.

Connected 8-component labeling of 0,1 image - i.e. find seperate
segmented objects and fill object pixels with object number

=for example

 $segmented = cc8compt( $image > $threshold );

',
       HandleBad => 0, # a marker
        Pars => 'a(m,n); [o]b(m,n);',
        Code => '

      PDL_Long i,j,k;
      PDL_Long newlabel;
      PDL_Long neighbour[4];
      PDL_Long nfound;
      PDL_Long pass,count,next,this;
      PDL_Long *equiv;
      PDL_Long i1,j1,i2;
      PDL_Long nx = $SIZE(m);
      PDL_Long ny = $SIZE(n);

      loop(n) %{ loop(m) %{ /* Copy */
         $b() = $a();
      %} %}

      /* 1st pass counts max possible compts, 2nd records equivalences */

      for (pass = 0; pass<2; pass++) {

      if (pass==1) {
         equiv = (PDL_Long*) malloc((newlabel+1)*sizeof(PDL_Long));
         if (equiv==(PDL_Long*)0)
            barf("Out of memory");
         for(i=0;i<=newlabel;i++)
             equiv[i]=i;
      }

      newlabel = 1; /* Running label */

      for(j=0; j<ny; j++) { for(i=0; i<nx; i++) { /* Loop over image pixels */

            nfound = 0; /* Number of neighbour >0 */

            i1 = i-1; j1 = j-1; i2 = i+1;

            if ($b(m=>i, n=>j) > 0) { /* Check 4 neighbour already seen */

               if (i>0 && $b(m=>i1, n=>j)>0)
                   neighbour[nfound++] = $b(m=>i1, n=>j); /* Store label of it */
               if (j>0 && $b(m=>i, n=>j1)>0)
                   neighbour[nfound++] = $b(m=>i, n=>j1);
               if (j>0 && i>0  && $b(m=>i1, n=>j1)>0)
                   neighbour[nfound++] = $b(m=>i1, n=>j1);
               if (j>0 && i<(nx-1) && $b(m=>i2, n=>j1)>0)
                   neighbour[nfound++] = $b(m=>i2, n=>j1);

               if (nfound==0)  { /* Assign new label */
                  $b(m=>i, n=>j) = newlabel++;
               }
               else {
                  $b(m=>i, n=>j) =  neighbour[0];
                  if (nfound>1 && pass == 1) {  /* Assign equivalents */
                      for(k=1; k<nfound; k++)
                         AddEquiv( equiv, (PDL_Long)$b(m=>i, n=>j),
                            neighbour[k] );
                  }
               }
            }

            else {  /* No label */

               $b(m=>i, n=>j) = 0;
            }

      }} /* End of image loop */

      } /* Passes */

      /* Replace each cycle by single label */

       count = 0;
       for (i = 1; i <= newlabel; i++)
         if ( i <= equiv[i] ) {
             count++;
             this = i;
             while ( equiv[this] != i ) {
               next = equiv[this];
               equiv[this] = count;
               this = next;
             }
          equiv[this] = count;
         }


      /* Now remove equivalences */

      for(j=0; j<ny; j++) { for(i=0; i<nx; i++) { /* Loop over image pixels */
           $b(m=>i, n=>j)   = equiv[ (PDL_Long) $b(m=>i, n=>j)  ] ;
      }}

      free(equiv); /* Tidy */
');

pp_addhdr('
#define MAXSEC 32
#define line(x1, x2, y) for (k=x1;k<=x2;k++) \
	{ /* printf("line from %d to %d\n",x1,x2); */ \
	image[k+wx*y] = col; }
#define PX(n) ps[2*n]
#define PY(n) ps[2*n+1]
	
void polyfill(PDL_Long *image, int wx, int wy, float *ps, int n,
	PDL_Long col, int *ierr)
{
   int ymin, ymax, xmin, xmax, fwrd = 1, i, j, k, nsect;
   int x[MAXSEC], temp, l;
   float s1, s2, t1, t2;
   
   ymin = PY(0); ymax = PY(0);
   xmin = PX(0); xmax = PX(0);
   *ierr = 0;
   
   for (i=1; i<n; i++) {
     ymin = ymin > PY(i) ? PY(i) : ymin;	
     ymax = ymax < PY(i) ? PY(i) : ymax;
     xmin = xmin > PX(i) ? PX(i) : xmin;	
     xmax = xmax < PX(i) ? PX(i) : xmax;
   }
   if (xmin < 0 || xmax >= wx || ymin < 0 || ymax >= wy) {
   	*ierr = 1; /* clipping */
	return;
   }
   s1 = PX(n-1);
   t1 = PY(n-1);
   for (l=ymin; l<= ymax; l++) {
	nsect = 0;
	fwrd = 1;
	for (i=0; i<n; i++) {
	  s2 = PX(i);
	  t2 = PY(i);
	  if ((t1 < l &&  l <= t2) || (t1 >= l && l > t2)) {
		if (nsect > MAXSEC) {
			*ierr = 2; /* too complex */
			return;
		}
		x[nsect] = (s1+(s2-s1)*((l-t1)/(t2-t1)));
	  	nsect += 1;
	  }
	  s1 = s2;
	  t1 = t2;
 	}
	/* sort the intersections */
	for (i=1; i<nsect; i++)
		for (j=0; j<i; j++)
			if (x[j] > x[i]) {
				temp = x[j];
				x[j] = x[i];
				x[i] = temp;
			}
	if (fwrd) {
		for (i=0; i<nsect-1; i += 2)
			line(x[i],x[i+1],l);
		fwrd = 0;
	} else {
		for (i=nsect-1; i>0; i -= 2)
			line(x[i-1],x[i],l);
		fwrd = 1;
	}
   }
}

');

pp_def('polyfill',
       HandleBad => 0, # a marker
	Pars => 'int [o,nc] im(m,n); float ps(two=2,np); int col()',
	Code => 'int ierr = 0, nerr;
	         threadloop %{
		   polyfill($P(im), $SIZE(m), $SIZE(n), $P(ps), $SIZE(np), $col(), &nerr);
		   ierr = ierr < nerr ? nerr : ierr;
		 %}
		 if (ierr) warn("errors during polygonfilling");
		 ',
	Doc => << 'EOD',
=for ref

fill the area inside the given polygon with a given colour

This function works inplace, i.e. modifies C<im>.

EOD
);

pp_add_exported('', 'polyfillv');
pp_addpm(<<'EOPM');

=head2 polyfillv

=for ref

return the (dataflown) area of an image within a polygon

=for example

  # increment intensity in area bounded by $poly
  $im->polyfillv($pol)++; # legal in perl >= 5.6
  # compute average intensity within area bounded by $poly
  $av = $im->polyfillv($poly)->avg;

=cut

sub PDL::polyfillv {
  my ($im, $ps) = @_;
  my $msk = zeroes(long,$im->dims);
  polyfill($msk, $ps, 1);
  return $im->where($msk == 1);
}
*polyfillv = \&PDL::polyfillv;

EOPM

pp_addhdr('#include "rotate.c"'."\n\n");
pp_add_exported('','rotnewsz');
pp_addxs('

void
rotnewsz(m,n,angle)
	int m
	int n
	float angle
	PPCODE:
	int newcols, newrows;

	if (getnewsize(m,n,angle,&newcols,&newrows) != 0)
		croak("wrong angle (should be between -90 and +90)");
	EXTEND(sp,2);
	PUSHs(sv_2mortal(newSVnv(newcols)));
	PUSHs(sv_2mortal(newSVnv(newrows)));
');

pp_def('rot2d',
       HandleBad => 0,
	Pars => 'im(m,n); float angle(); bg(); int aa(); [o] om(p,q)',
	Code => 'int ierr;
		 if ((ierr = rotate($P(im),$P(om),$SIZE(m),$SIZE(n),$SIZE(p),
			$SIZE(q),$angle(),$bg(),$aa())) != 0)
			if (ierr == -1)
				croak("error during rotate, wrong angle");
			else
				croak("wrong output dims, did you set them?");
		',
	# ugly workaround since $SIZE(m) and $SIZE(n) are not initialized
	# when the redodimscode is called
	# need to fix this!
	RedoDimsCode => 'int ncols, nrows;
			if ($PDL(im)->ndims < 2)
				croak("need > 2d piddle");
			if (getnewsize($PDL(im)->dims[0],$PDL(im)->dims[1],
				$angle(), &ncols,
				&nrows) != 0) 
			   croak("error during rotate, wrong angle");
			/* printf("o: %d, p: %d\n",ncols,nrows); */
			$SIZE(p) = ncols;
			$SIZE(q) = nrows;',
	GenericTypes => ['B'],
	Doc => << 'EOD',
=for ref

rotate an image by given C<angle>

=for example

  # rotate by 10.5 degrees with antialiasing, set missing values to 7
  $rot = $im->rot2d(10.5,7,1);

This function rotates an image through an C<angle> between -90 and + 90
degrees. Uses/doesn't use antialiasing depending on the C<aa> flag.
Pixels outside the rotated image are set to C<bg>.

Code modified from pnmrotate (Copyright Jef Poskanzer) with an algorithm based
on "A Fast Algorithm for General  Raster  Rotation"  by  Alan Paeth,
Graphics Interface '86, pp. 77-81.

Use the C<rotnewsz> function to find out about the dimension of the
newly created image

  ($newcols,$newrows) = rotnewsz $oldn, $oldm, $angle;

EOD
);

pp_def('bilin2d',
       HandleBad => 0,
    Pars => 'I(n,m); O(q,p)',
    Doc=><<'EOD',
=for ref

Bilineary maps the first piddle in the second. The
interpolated values are actually added to the second
piddle which is supposed to be larger than the first one.

EOD
,
    Code =>'
  int i,j,ii,jj,ii1,jj1,num;
  double x,y,dx,dy,y1,y2,y3,y4,t,u,sum;

  if ($SIZE(q)>=$SIZE(n) && $SIZE(p)>=$SIZE(m)) {
    threadloop %{
      dx = ((double) ($SIZE(n)-1)) / ($SIZE(q)-1);
      dy = ((double) ($SIZE(m)-1)) / ($SIZE(p)-1);
      for(i=0,x=0;i<$SIZE(q);i++,x+=dx) {
	for(j=0,y=0;j<$SIZE(p);j++,y+=dy) {
	  ii = (int) floor(x);
	  if (ii>=($SIZE(n)-1)) ii = $SIZE(n)-2;
	  jj = (int) floor(y);
	  if (jj>=($SIZE(m)-1)) jj = $SIZE(m)-2;
	  ii1 = ii+1;
	  jj1 = jj+1;
	  y1 = $I(n=>ii,m=>jj);
	  y2 = $I(n=>ii1,m=>jj);
	  y3 = $I(n=>ii1,m=>jj1);
	  y4 = $I(n=>ii,m=>jj1);
	  t = x-ii;
	  u = y-jj;
	  $O(q=>i,p=>j) += (1-t)*(1-u)*y1 + t*(1-u)*y2 + t*u*y3 + (1-t)*u*y4;
	}
      }
      %}
  }
  else { 
    barf("the second matrix must be greater than first! (bilin2d)");
  }
');

pp_def('rescale2d',
       HandleBad => 0,
    Pars => 'I(n,m); O(q,p)',
    Doc=><<'EOD',
=for ref

The first piddle is rescaled to the dimensions of the second
(expandind or meaning values as needed) and then added to it.

EOD
,
    Code =>'
int ix,iy,ox,oy,i,j,lx,ly,cx,cy,xx,yy,num;
double kx,ky,temp;

ix = $SIZE(n);   
iy = $SIZE(m);   
ox = $SIZE(p);   
oy = $SIZE(q);   

if(ox >= ix && oy >= iy) {
  threadloop %{
    kx = ((double) (ox)) / (ix);
    ky = ((double) (oy)) / (iy);
    lx = 0;
    for(i=0;i<ix;i++) {
      ly = 0;
      for(j=0;j<iy;j++) {
	cx = rint((i+1)*kx)-1;
	cy = rint((j+1)*ky)-1;
	for(xx=lx;xx<=cx;xx++)
	  for(yy=ly;yy<=cy;yy++) {
/*	    fprintf(stderr,"i: %d, j: %d, xx: %d, yy: %d\n",i,j,xx,yy); */
	    $O(p=>xx,q=>yy) += $I(n=>j,m=>i);
	  }
	ly = cy + 1;
      }
      lx = cx + 1;
    }
  %}
}
else if(ox < ix && oy < iy) {
  threadloop %{
    kx = ((double) (ix)) / (ox);
    ky = ((double) (iy)) / (oy);
    lx = 0;
    for(i=0;i<ox;i++) {
      ly = 0;
      for(j=0;j<oy;j++) {
	cx = rint((i+1)*kx)-1;
	cy = rint((j+1)*ky)-1;
	temp = 0.0;
	num = 0;
	for(xx=lx;xx<=cx;xx++)
	  for(yy=ly;yy<=cy;yy++) {
/*	    fprintf(stderr,"i: %d, j: %d, xx: %d, yy: %d\n",i,j,xx,yy); */
	    temp += $I(n=>yy,m=>xx);
	    num++;
	  }
	$O(p=>i,q=>j) += temp/num;
	ly = cy + 1;
      }
      lx = cx + 1;
    }
  %}
}
else if(ox >= ix && oy < iy) {
  threadloop %{
    kx = ((double) (ox)) / (ix);
    ky = ((double) (iy)) / (oy);
    lx = 0;
    for(i=0;i<ix;i++) {
      ly = 0;
      for(j=0;j<oy;j++) {
	cx = rint((i+1)*kx)-1;
	cy = rint((j+1)*ky)-1;
	temp = 0.0;
	num = 0;
	for(yy=ly;yy<=cy;yy++) {
/*	  fprintf(stderr,"1 i: %d, j: %d, xx: %d, yy: %d\n",i,j,xx,yy); */
	    temp += $I(n=>yy,m=>i);
	  num++;
	}
	for(xx=lx;xx<=cx;xx++) {
/*	  fprintf(stderr,"2 i: %d, j: %d, xx: %d, yy: %d\n",i,j,xx,yy); */
	  $O(p=>xx,q=>j) += temp/num;
	}
	ly = cy + 1;
      }
      lx = cx + 1;
    }
  %}
}
else if(ox < ix && oy >= iy) {
  threadloop %{
    kx = ((double) (ix)) / (ox);
    ky = ((double) (oy)) / (iy);
    lx = 0;
    for(i=0;i<ox;i++) {
      ly = 0;
      for(j=0;j<iy;j++) {
	cx = rint((i+1)*kx)-1;
	cy = rint((j+1)*ky)-1;
	temp = 0.0;
	num = 0;
	for(xx=lx;xx<=cx;xx++) {
/*	  fprintf(stderr,"1 i: %d, j: %d, xx: %d, yy: %d\n",i,j,xx,yy); */
	    temp += $I(n=>j,m=>xx);
	  num++;
	}
	for(yy=ly;yy<=cy;yy++) {
/*	  fprintf(stderr,"2 i: %d, j: %d, xx: %d, yy: %d\n",i,j,xx,yy); */
	  $O(p=>i,q=>yy) += temp/num;
	}
	ly = cy + 1;
      }
      lx = cx + 1;
    }
  %}
}
else barf("I am not supposed to be here, please report the bug to <chri@infis.univ.ts.it>");
  ');

pp_done();
