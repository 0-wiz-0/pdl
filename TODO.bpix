
Problems:
=========

.) get the tests fixed

.) improve the documentation support (such as get it working properly).
   The logic needs tweaking for the automatic document creation,
   and the output needs beautifying.

.) $pdl->badvalue(23) should change the bad value in $pdl to 23
   (as well as changing the default bad value, which it does)

Suggestions/To do:
================

.) NaN support - this would make it *much* faster on machines which
   support it. See the section in IMPLEMENTATION.bpix
   I've started labelling routines which will have to use the BadCode
   section even when using NaN's by 'UseBadforNaN => 1' - this
   doesn't yet do anything.

.) 'bad-ify' the rest of the code...

.) we need something like 'badwhere($a < 20)' which returns a 
   piddle in which those elements which pass the condition are
   set bad, otherwise 0 (and has it's bad flag set). This 
   would allow you to replace values less than 20 with the bad value 
   by '$a += badwhere($a < 20)' (or maybe *=)
      EXCEPT THAT it shouldn't be called 'where', and probably won't
      work like this at all...
   See t/bad.t for foofoobad() --- This needs thinking about

   Actually, what I think we want is 'setbadif( $a < 20 )' to return
   a copy of $a which:
     a) has its bad flag set 
     b) elements with $a < 20 are set bad
     c) other elements are left alone

   This would mean you could type '$a = setbadif( $a < 20 )'

   Comments?

.) divide in ops.pd should trap '/ 0' cases as well. also special cases 
   for sqrt(), log ... and integration with NaN support

.) With the current scheme, it would be possible to have a per-piddle
   bad value. However, new piddles would use the default values.
   All it would need (I think) is for newly-created piddles to have
   their badvalue set to the default value -- I'm just not sure
   when new piddles are created within the C code! Then PdlParObj's
   get_xsdatapdecl() method needs changing to access the per-piddle
   bad value rather than the values stored in the PDL->bvals
   structure. The actual code wouldn't need changing, as long as it 
   was written using the $ISGOOD/ISBAD/SETBAD macros.

   It would be redundant if we used NaN support - so maybe we should 
   put this on the back-burner until we get Nan support.

   I'm moving away from the idea of per-piddle bad values, as I think
   it would increase the amount of code in certain cases.

.) $pdl->baddata() now updates all the children of this piddle
   as well. However, not sure what to do with parents, since:
     $b = $a->slice(); 
     $b->baddata(0)
   doesn't mean that $a shouldn't have it's badvalue cleared.
   however, after
     $b->baddata(1)
   it's sensible to assume that the parents now get flagged as
   containing bad values.

   PERHAPS you can only clear the bad value flag if you are NOT
   a child of another piddle, whereas if you set the flag then all
   children AND parents should be set as well?

   Similarly, if you change the bad value in a piddle, should this
   be propogated to parent & children? Or hsould you only be able to do
   this on the 'top-level' piddle?

.) get some code set up to do benchmarks to see how much things are
   slowed down (and to check that I haven't messed things up if
   WITH_BADVAL is 0/undef).

.) some of the names aren't appealing - I'm thinking of orig_badvalue()
   in Basic/Bad/bad.pd in particular. Any suggestions appreciated.

.) Basic/Core/pdlconv.c.PL - I don't understand when pdl_converttype()
   is called, so I've included a check that prints a message to STDERR
   if it's called with a bad piddle. This will need removing at some
   point as it's wasted space...

.) [not really bad pixel stuff] - are the #define THISIS... lines
   necessary in type-looped PP code?

