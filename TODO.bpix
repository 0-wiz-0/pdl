
Problems:
=========

.) what to do about 'any($a > 20)' when all elements of $a are bad:
    orover($a > 20) will produce a bad value, which is then returned
   to the caller as a scaler (via 'return $tmp->at()').
   a) should we just die
   b) should we return bad (as it's a scalar we would have to ensure
      that it was converted to the type of the input piddle first)
   c) call a user-defined sub-routine?
   d) ...
   (also for avg,zcheck,... in primitive.pd)

.) improve the documentation support (such as get it working properly).
   The logic may need tweaking for the automatic document creation,
   and the output definitely needs beautifying.

.) $pdl->badvalue(23) should change the bad value in $pdl to 23
   (as well as changing the default bad value, which it does)

.) improve the tests

.) remove 'UseBadforNan => 1' and replace with something like
   'NoBadifNaN' (if true then can ignore the BadCode/...
   segment - ir opposite logic to UseBadforNaN)

.) Revamp PDLCode.pm - have an object whose get_str() does something 
   like 'if ( badflag ) { badcode } else { goodcode }' - this would
   mean we don't need the same number of threadloop's etc in good/badcode

.) looks like starlink's byte goes from -127 to 127 - ie not unsigned.

Suggestions/To do:
================

.) NaN support - this would make it *much* faster on machines which
   support it. See the section in IMPLEMENTATION.bpix
   I've started labelling routines which will have to use the BadCode
   section even when using NaN's by 'UseBadforNaN => 1' - this
   doesn't yet do anything.

.) 'bad-ify' the rest of the code...

.) do any more routines need to be converted to work inplace (done
   replacebad)?

.) divide in ops.pd should trap '/ 0' cases as well. also special cases 
   for sqrt(), log ... and integration with NaN support

.) With the current scheme, it would be possible to have a per-piddle
   bad value. However, new piddles would use the default values.
   All it would need (I think) is for newly-created piddles to have
   their badvalue set to the default value -- I'm just not sure
   when new piddles are created within the C code! Then PdlParObj's
   get_xsdatapdecl() method needs changing to access the per-piddle
   bad value rather than the values stored in the PDL->bvals
   structure. The actual code wouldn't need changing, as long as it 
   was written using the $ISGOOD/ISBAD/SETBAD macros.

   It would be redundant if we used NaN support - so maybe we should 
   put this on the back-burner until we get Nan support.

   I'm moving away from the idea of per-piddle bad values, as I think
   it would increase the amount of code in certain cases.

.) $pdl->baddata() now updates all the children of this piddle
   as well. However, not sure what to do with parents, since:
     $b = $a->slice(); 
     $b->baddata(0)
   doesn't mean that $a shouldn't have it's badvalue cleared.
   however, after
     $b->baddata(1)
   it's sensible to assume that the parents now get flagged as
   containing bad values.

   PERHAPS you can only clear the bad value flag if you are NOT
   a child of another piddle, whereas if you set the flag then all
   children AND parents should be set as well?

   Similarly, if you change the bad value in a piddle, should this
   be propogated to parent & children? Or hsould you only be able to do
   this on the 'top-level' piddle?

.) get some code set up to do benchmarks to see how much things are
   slowed down (and to check that I haven't messed things up if
   WITH_BADVAL is 0/undef).

.) some of the names aren't appealing - I'm thinking of orig_badvalue()
   in Basic/Bad/bad.pd in particular. Any suggestions appreciated.

.) Basic/Core/pdlconv.c.PL - I don't understand when pdl_converttype()
   is called, so I've included a check that prints a message to STDERR
   if it's called with a bad piddle. This will need removing at some
   point as it's wasted space...

