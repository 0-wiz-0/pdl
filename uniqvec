=head2 uniqvec

=for ref

return all unique vectors out of a collection

  NOTE: If any vectors in the input piddle have NaN values
  they are returned at the end of the non-NaN ones.  This is
  because, by definition, NaN values never compare equal with
  any other value.

The unique vectors are returned in lexicographically sorted
ascending order.  The 0th dimension of the input PDL is treated
as a dimensional index within each vector, and the 1st and any higher
dimensions are taken to run across vectors.  The return value is always
2D; any structure of the input PDL (beyond using the 0th dimension 
for vector index) is lost.  

See also L<uniq|uniq> for a uniqe list of scalars; and
L<qsortvec|PDL::Ufunc/qsortvec> for sorting a list of vectors
lexicographcally.

=cut




=for bad

If a vector contains all bad values, it is ignored as in L<uniq|uniq>.
If some of the values are good, it is treated as a normal vector. For
example, [1 2 BAD] and [BAD 2 3] could be returned, but [BAD BAD BAD] 
could not.

=cut




sub PDL::uniqvec {
   my($pdl) = shift;

   return $pdl if $pdl->nelem==0;
   return $pdl->uniq->dummy(0) if ( $pdl->ndims<2 || $pdl->slice("(0)")->nelem<2 );  # slice isn't cheap but uniqvec isn't either

   our $pdl2d = $pdl->mv(0,-1)->clump($pdl->ndims-1)->mv(-1,0);                      # clump all but dim(0)

   our $ngood = $pdl2d->ones->sumover;
   our $ngood = $pdl2d->ngoodover if  ($PDL::Bad::Status && $pdl->badflag);          # number of good values each vector
   our $ngood2 = $ngood->where($ngood);                                              # number of good values with no all-BADs
   
   $pdl2d = $pdl2d->mv(0,-1)->dice($ngood->which)->mv(-1,0);                         # remove all-BAD vectors

   our $numnan   = ($pdl2d!=$pdl2d)->sumover;                                        # works since no all-BADs to confuse
   our $presrt = $pdl2d->mv(0,-1)->dice($numnan->not->which)->mv(0,-1);              # remove vectors with any NaN values

   # use dice instead of nslice since qsortvec might be packing
   # the badvals to the front of the array instead of the end like
   # the docs say. If that is the case and it gets fixed, it won't
   # bust uniqvec. DAL 14-March 2006

   our $srt = $presrt->qsortvec->mv(0,-1);                                           # BADs are sorted by qsortvec
   our $srtdice = $srt;
   if  ($PDL::Bad::Status && $srt->badflag) {
      $srtdice = $srt->dice($srt->mv(0,-1)->ngoodover->which);
   }

   our $uniq;
   if ($srtdice->nelem > 0) {
      $uniq = ($srtdice != $srtdice->rotate(-1))->mv(0,-1)->orover->which;
   } else {
      $uniq = $srtdice->orover->which;
   }

   # TODO: need to append the BAD value and NaN containing vectors to
   # the end of the result piddle.  What sort of ordering makes sense
   # with both NaN and BAD in the same piddle?      -chm 15-June-2010

   return $uniq->nelem==0 ? 
   $srtdice->slice("0,:")->mv(0,-1) :
   $srtdice->dice($uniq)->mv(0,-1);
}

1;
