--------------------------------------------------------------------------------

                        Bad value support in PDL

 Doug Burke (burke@ifa.hawaii.edu) & ...
 last update: 07/11/00

--------------------------------------------------------------------------------

See README.bpix for a brief overview.

--------------------------------------------------------------------------------

Implementation details
======================

Various bits of code use either perldl.conf or PDL::Config to find out whether
to support bad values.

A new flag has been added to the state of a piddle - PDL_BADVAL. If unset, then
the piddle does not contain bad values, and so all the support code can be 
ignored. If set, it does not guarantee that bad values are present, just that
they should be checked for. Thanks to help from Christian, baddata() - which 
sets/clears this flag (see Bad/bad.pd) - will update ALL the 
children/grandchildren/etc of a piddle if its state changes (see 
propogate_badflag in Bad/bad.pd). It's not clear what to do with parents: I can 
see the reason for propogating a 'set badflag' request to parents, but I think 
a child should NOT be able to clear the badflag of a parent. 
  Suggestions welcome.

The pdl_trans structure has been extended to include an integer value,
bvalflag, which acts as a switch to tell the code whether to handle bad values
or not. This value is set if any of the input piddles have their PDL_BADVAL 
flag set (although this code can be replaced by setting FindBadStateCode in 
pp_def). I tried using the flags field in the trans struct, but it was 
occasionally getting cleared during calls to PDL->make_trans_mutual(). See the 
get/set/clear_badval subs in PP.pm, one get_str() sub in PP/PDLCode.pm and
un-comment the PDL_ITRANS_HAVE_BADFLAG lines in Core/pdl.h.PL (as well as
comment out the bvalflag line in the trans structure) if you want to 
investigate further.

The bad values are now stored in a structure within the Core PDL structure
- PDL.bvals (eg pdlcore.h.PL); see also 'typedef badvals' in pdl.h.PL and the
BOOT code of Core.xs.PL where the values are initialised to (hopefully)
sensible values. See PDL/Bad/bad.pd for read/write routines to
these values.

The default/original bad values are set to (taken from the Starlink
distribution):

#include <float.h>
#include <limits.h>

PDL_Byte    ==  UCHAR_MAX
PDL_Short   ==   SHRT_MIN
PDL_Ushort  ==  USHRT_MAX
PDL_Long    ==    INT_MIN
PDL_Float   ==   -FLT_MAX
PDL_Double  ==   -DBL_MAX

Some of the present functionality (and lack of it) can be found in t/bad.t

How do I change some pp_code to handle bad values?
==================================================

Examples can be found in Basic/Bad/bad.pd, Basic/Primitive/primitive.pd,
Basic/Ops/ops.pd, Slices/Slices/slices.pd, and hopefully many more places
soon.

All routines should automatically propogate the bad status flag to output
piddles, unless you declare otherwise.

To flag a routine as NOT handling bad values, use 
   HandleBad => 0
This *should* cause the routine to print a warning if it's sent any piddles
with the bad flag set. Primitive's intover has had this set, but I've not
tried it out to see if it works.

If you want to handle bad values but not set the state of all the output
piddles, or if it's only one input piddle that's important, then look
at the PP rules NewXSFindBadStatus and NewXSCopyBadStatus and the
corresponding pp_def options
   FindBadStatusCode and CopyBadStatusCode
I've only just started to use this functionality - see zcover in primitive.pd
and isbadover/isgoodover in bad.pd.
(there's a problem with zcover but I don't think it's to do with this). 

If the option
   HandleBad => 1
is given, then the readdata code automatically creates a variable called
<pdl name>_badval, which contains the badvalue for that piddle (see
get_xsdatapdecl() in PP/PdlParObjs.pm). After Tuomas' suggestion, macros
have been set up to provide easy access:

  '$ISBAD($a(n=>1))'  expands to '$a(n=>1) == a_badval'
  '$ISGOOD($a())'                '$a()     != a_badval'
  '$SETBAD($bob())'              '$bob()    = bob_badval'

(well, the $a(...) is expanded as well). The following have been
introduced, since they are used in the default EquivCPOffsCode -
see the $EQUIVCPOFFS_BAD() 'macro' in that rule and it's expansion
in the CODE rule. They may need playing around with to improve
their use.

  '$PPISBAD(CHILD,[i])           'CHILD_physdatap[i] == CHILD_badval'
  '$PPISGOOD(CHILD,[i])          'CHILD_physdatap[i] != CHILD_badval'
  '$PPSETBAD(CHILD,[i])          'CHILD_physdatap[i] = CHILD_badval'

This means that you can change
   Code => '$a() = $b() + $c();'
to
   BadCode => 'if ( $ISBAD($b()) || $ISBAD($c()) ) { 
                 $SETBAD($a()); 
               } else {
                 $a() = $b() + $c();
               }'
leaving Code as it is. PP::PDLCode will then create a loop something like
   if ( __trans->bvalflag ) {
        threadloop over BadCode
   } else { 
        threadloop over Code
   }
it's probably easier to just look at the .xs file to see what goes on.

NOTE: the above relies on horrible hacking of PDL::PP::Code and
PDL::PP::ComplexThreadLoop (eg PP/PDLCode.pm), since I couldn't see a way, 
using the current system, to get a loop like the above. If you can, 
please implement!

Similar to BadCode, there's BadBackCode, and BadRedoDimsCode, although
these haven't been used yet.

EquivCPOffsCode has been changed to understand bad values - with a
$EQUIVCPOFFS_BAD macro as well - although I don't really understand what 
I'm doing here!

Please note that the current design is based on my failure to understand
what the xxx_redodims(), xxx_copy(), xxx_free() functions that are 
created by PP do. (ie I haven't changed them)

There's (to my mind at least!) issues about how to handle comparison
operators - see TODO.bpix and the comments near zcover() in primitive.pd.

Why not use NaN (IEEE) when present?
====================================

Short answer: because I don't know how. 

After talking with Tim Jenness, it looks like it should be able to get
the code to use NaN's as bad values if available - this should mean we can
skip the checks for bad values in the C code, since f(x) with x = NaN
produces NaN, and does it quickly (apparently). 

Basically, PP.pm would ignore the BadCode/BadBackCode/etc pp_def()
options, just using the Code/... options instead. The supporting code
would still be used. Perhaps it would be necessary to provide NaNCode/...
options in case falling back to Code is not sufficient in certain cases.

I'd love someone to try this.

Other notes
===========

The build process has been affected. The following files are
now created during the build:
  Basic/Core/Dev.pm      by mkdev.pl
             pdlcore.h      pdlcore.h.PL
             pdlapi.c       pdlapi.c.PL
             Core.xs        Core.xs.PL
             Core.pm        Core.pm.PL     

We can't use Dev.pm.PL, since Dev.pm is used by the Makefile.PL's,
so must be created as soon as possible.

Several new files have been added:
  README.bpix
  Changes.bpix
  IMPLEMENTATION.bpix

  t/bad.t

  Basic/Bad/
  Basic/Bad/Makefile.PL
            bad.pd
