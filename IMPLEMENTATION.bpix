--------------------------------------------------------------------------------

                        Bad value support in PDL

 Doug Burke (burke@ifa.hawaii.edu) & ...
 last update: 08/03/00

--------------------------------------------------------------------------------

See README.bpix for a brief overview.

Sections:
  Implementation details
  How do I change some pp_code to handle bad values?
  Why not use NaN (IEEE) when present?
  What about documentation?
  Other notes

--------------------------------------------------------------------------------

Implementation details
======================

Various bits of code use either perldl.conf or PDL::Config to find out whether
to support bad values (user code can examine the value of $PDL::Bad::Status).

A new flag has been added to the state of a piddle - PDL_BADVAL. If unset, then
the piddle does not contain bad values, and so all the support code can be 
ignored. If set, it does not guarantee that bad values are present, just that
they should be checked for. Thanks to help from Christian, badflag() - which 
sets/clears this flag (see Bad/bad.pd) - will update ALL the 
children/grandchildren/etc of a piddle if its state changes (see 
propogate_badflag in Bad/bad.pd). It's not clear what to do with parents: I can 
see the reason for propogating a 'set badflag' request to parents, but I think 
a child should NOT be able to clear the badflag of a parent. There's also the
issue of what happens when you change the bad value for a piddle.
 *** SEE the discussion of this in README.bpix ***

The pdl_trans structure has been extended to include an integer value,
bvalflag, which acts as a switch to tell the code whether to handle bad values
or not. This value is set if any of the input piddles have their PDL_BADVAL 
flag set (although this code can be replaced by setting FindBadStateCode in 
pp_def). I tried using the flags field in the trans struct, but it was 
occasionally getting cleared during calls to PDL->make_trans_mutual(). 

The bad values are now stored in a structure within the Core PDL structure
- PDL.bvals (eg pdlcore.h.PL); see also 'typedef badvals' in pdl.h.PL and the
BOOT code of Core.xs.PL where the values are initialised to (hopefully)
sensible values. See PDL/Bad/bad.pd for read/write routines to
these values.

The default/original bad values are set to (taken from the Starlink
distribution):

#include <float.h>
#include <limits.h>

PDL_Byte    ==  UCHAR_MAX
PDL_Short   ==   SHRT_MIN
PDL_Ushort  ==  USHRT_MAX
PDL_Long    ==    INT_MIN
PDL_Float   ==   -FLT_MAX
PDL_Double  ==   -DBL_MAX

Some of the present functionality (and lack of it) can be found in t/bad.t
or 'demo bad' within perldl.

--------------------------------------------------------------------------------

How do I change some pp_code to handle bad values?
==================================================

Examples can be found in Basic/Bad/bad.pd, Basic/Primitive/primitive.pd,
Basic/Ops/ops.pd, Slices/Slices/slices.pd, and hopefully many more places
soon. Some of the logic might appear a bit unclear - that's probably because it
is! Comments appreciated.

All routines should automatically propogate the bad status flag to output
piddles, unless you declare otherwise.

If a routine explicitly deals with bad values, you must provide this option
to pp_def:
   HandleBad => 1
This ensures that the correct variables are initialised for the $ISBAD etc
macros. It is also used by the automatic document-creation routines to
provide default information on the bad value support of a routine without
the user having to type it themselves. (this is in its early stages).

To flag a routine as NOT handling bad values, use 
   HandleBad => 0
This *should* cause the routine to print a warning if it's sent any piddles
with the bad flag set. Primitive's intover has had this set, but I've not
tried it out to see if it works.

If you want to handle bad values but not set the state of all the output
piddles, or if it's only one input piddle that's important, then look
at the PP rules NewXSFindBadStatus and NewXSCopyBadStatus and the
corresponding pp_def options
   FindBadStatusCode and CopyBadStatusCode
A number of routines use this - eg isXXXover (bad.pd) and zcover
(primitive.pd). 

If you have a routine that you want to be able to use as inplace, look
at the routines in bad.pd which use the 'Inplace' option to see how the
bad flag is propogated to children using the xxxBadStatusCode options
(or those in ops.pd). Decided not to automate this as rules would be a
little complex, since not every inplace op will need to propogate the 
badflag (eg unary functions).

If the option
   HandleBad => 1
is given, then the readdata code automatically creates a variable called
<pdl name>_badval, which contains the badvalue for that piddle (see
get_xsdatapdecl() in PP/PdlParObjs.pm). After Tuomas' suggestion, macros
have been set up to provide easy access:

  '$ISBAD(a(n=>1))'  expands to '$a(n=>1) == a_badval'
  '$ISGOOD(a())'                '$a()     != a_badval'
  '$SETBAD(bob())'              '$bob()    = bob_badval'

well, the $a(...) is expanded as well. Also, you can use a $ before the
pdl name, if you so wish, but it begins to look like line noise -
eg '$ISGOOD($a())'.

If you cache a piddle value in a variable -- eg index in slices.pd --
the following routines are useful:
 
   '$ISBADVAR(c_var,pdl)'     'c_var == pdl_badval'
   '$ISGOODVAR(c_var,pdl)'    'c_var != pdl_badval'
   '$SETBADVAR(c_var,pdl)'    'c_var  = pdl_badval'

The following have been introduced, They may need playing around with to 
improve their use.

  '$PPISBAD(CHILD,[i])           'CHILD_physdatap[i] == CHILD_badval'
  '$PPISGOOD(CHILD,[i])          'CHILD_physdatap[i] != CHILD_badval'
  '$PPSETBAD(CHILD,[i])          'CHILD_physdatap[i]  = CHILD_badval'

This means that you can change
   Code => '$a() = $b() + $c();'
to
   BadCode => 'if ( $ISBAD(b()) || $ISBAD(c()) ) { 
                 $SETBAD(a()); 
               } else {
                 $a() = $b() + $c();
               }'

leaving Code as it is. PP::PDLCode will then create a loop something like

   if ( __trans->bvalflag ) {
        threadloop over BadCode
   } else { 
        threadloop over Code
   }

it's probably easier to just look at the .xs file to see what goes on.

As of 07/27/00, PDLCode.pm has been rewritten. It's no longer such a hack,
and now you don't need to have the same number of 'threadloop %{ %}'
in Code and BadCode.

Similar to BadCode, there's BadBackCode, and BadRedoDimsCode.

Handling EquivCPOffsCode is a bit different: under the assumption that the
only access to data is via the '$EQUIVCPOFFS(i,j)' macro, then we can 
automatically create the 'bad' version of it; see the [EquivCPOffsCode]
and [Code] rules.

Macros have been provided to provide access to the bad-flag status of 
a pdl:

  '$PDLSTATEISBAD(a)'    -> '($PDL(a)->state & PDL_BADVAL) > 0'
  '$PDLSTATEISGOOD(a)'      '($PDL(a)->state & PDL_BADVAL) == 0'

  '$PDLSTATESETBAD(a)'      '$PDL(a)->state |= PDL_BADVAL'
  '$PDLSTATESETGOOD(a)'     '$PDL(a)->state &= ~PDL_BADVAL'

For use in xxxxBadStatusCode (+ other stuff that goes into the INIT: section)
there are:
  '$SETPDLSTATEBAD(a)'       -> 'a->state |= PDL_BADVAL'
  '$SETPDLSTATEGOOD(a)'      -> 'a->state &= ~PDL_BADVAL'

  '$ISPDLSTATEBAD(a)'        -> '((a->state & PDL_BADVAL) > 0)'
  '$ISPDLSTATEGOOD(a)'       -> '((a->state & PDL_BADVAL) == 0)'

Please note that the current design is based on my failure to understand
what the xxx_redodims(), xxx_copy(), xxx_free() functions that are 
created by PP do. (ie I haven't changed them)

--------------------------------------------------------------------------------

Why not use NaN (IEEE) when present?
====================================

Short answer: because I don't know how. 

After talking with Tim Jenness, it looks like it should be able to get
the code to use NaN's as bad values if available - this should mean we can
skip the checks for bad values in the C code, since f(x) with x = NaN
produces NaN, and does it quickly (apparently). However, many routines would
remain unchanged (eg counting the number of bad values, or summing up all the
values).

Basically, PP.pm would ignore the BadCode/BadBackCode/etc pp_def()
options, just using the Code/... options instead. The supporting code
would still be used (ie for setting the bad flag on output piddles etc).
Some routines would still need explicit code to handle NaN values (eg min, 
max, median - see primitive.pd) - we should be able to use the existing
BadCode/etc values for these.

I have started adding the poorly-named option 'NoBadifNaN => 1'
to those routines which should be able to ignore the BadCode options.
It's currently a NOP, and only added to bad.pd and math.pd. Other files
still contain the option 'UseBadforNaN', which I'd added to flag those 
routines which would need to retain the BadCode segment. However, there are 
more of the latter than the former, hence the switch (I'm lazy).

The PDL::PP::BadAccess, PDL::PP::BadVarAccess, and PDL::PP::PPBadAccess objects 
in Basic/PP/PDLCore.pm *MAY* need updating to produce different code depending 
on whether NaN support was available or not.

I'd love someone to try this. 

--------------------------------------------------------------------------------

What about documentation?
=========================

One of the strengths of PDL is it's on-line documentation. The aim is to use
this system to provide informtion on how/if a routine supports bad values:
in many cases pp_def() contains all the information anyway, so the 
function-writer doesn't need to do anything at all! For the cases when this is
not sufficient, there's the 'BadDoc' option to pp_def(). For code written at
the perl level - ie in a .pm file - use the '=for bad' pod directive.

This information will be available via man/pod2man/html documenation. It's also
accessible from the perldl shell - using the 'badinfo' command - and the pdldoc
shell command - using the '-b' option.

This support is at a very early stage - ie not much thought has gone into it:
comments are welcome; improvements to the code preferred ;)

--------------------------------------------------------------------------------

Other notes
===========

The build process has been affected. The following files are
now created during the build:
  Basic/Core/Dev.pm      by mkdev.pl
             pdlcore.h      pdlcore.h.PL
             pdlapi.c       pdlapi.c.PL
             Core.xs        Core.xs.PL
             Core.pm        Core.pm.PL     

We can't use Dev.pm.PL, since Dev.pm is used by the Makefile.PL's,
so must be created as soon as possible.

Several new files have been added:
  README.bpix
  Changes.bpix
  IMPLEMENTATION.bpix

  t/bad.t

  Basic/Bad/
  Basic/Bad/Makefile.PL
            bad.pd
