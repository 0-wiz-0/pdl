--------------------------------------------------------------------------------

                        Bad value support in PDL

 Doug Burke (burke@ifa.hawaii.edu) & ...
 last update: 07/10/00

--------------------------------------------------------------------------------

Implementation details
======================

Various bits of code use either perldl.conf or PDL::Config to find out whether
to support bad values.

A new flag has been added to the state of a piddle - PDL_BADVAL. If unset, then
the piddle does not contain bad values, and so all the support code can be 
ignored. If set, it does not guarantee that bad values are present, just that
they should be checked for.

The pdl_trans structure has been extended to include an integer value,
bvalflag, which acts as a switch to tell the code whether to handle bad values
or not (perhaps I should have just used the flags variable in the pdl_trans
structure since it's a bit wasteful to have an integer here). This value is
set if any of the input piddles have their PDL_BADVAL flag set (althogh
this code can be replaced by setting FindBadStateCode in pp_def).

The bad values are now stored in a structure within the Core PDL structure
- PDL.bvals (eg pdlcore.h.PL); see also 'typedef badvals' in pdl.h.PL and the
BOOT code of Core.xs.PL where the values are initialised to (hopefully)
sensible values. Although with these values my linux machine crashes whilst
my solaris machine is okay! See PDL/Bad/bad.pd for read/write routines to
these values.

The default/original bad values are set to (taken from the Starlink
distribution):

#include <float.h>
#include <limits.h>

PDL_Byte    ==  UCHAR_MAX
PDL_Short   ==   SHRT_MIN
PDL_Ushort  ==  USHRT_MAX
PDL_Long    ==    INT_MIN
PDL_Float   ==   -FLT_MAX
PDL_Double  ==   -DBL_MAX

Some of the present functionality (and lack of it) can be found in t/bad.t

How do I change some pp_code to handle bad values?
==================================================

Examples can be found in Basic/Bad/bad.pd, Basic/Primitive/primitive.pd,
Basic/Ops/ops.pd, Slices/Slices/slices.pd, and hopefully many more places
soon.

All routines should automatically propogate the bad status flag to output
piddles, unless you declare otherwise.

To flag a routine as NOT handling bad values, use 
   HandleBad => 0
This *should* cause the routine to print a warning if it's sent any piddles
with the bad flag set, although I haven't changed anything to 'HandleBad => 0'
yet to check this out.

If you want to handle bad values but not set the state of all the output
piddles, or if it's only one input piddle that's important, then look
at the PP rules NewXSFindBadStatus and NewXSCopyBadStatus and the
corresponding pp_def options
   FindBadStatusCode and CopyBadStatusCode
I've only just started to use this functionality - see zcover in primitive.pd
and isbadover/isgoodover in bad.pd.
(there's a problem with zcover but I don't think it's to do with this since it
also affects other routines such as ngoodover/nbadover in Basic/Bad/bad.pd). 

If the option
   HandleBad => 1
is given, then the readdata code automatically creates a variable called
<pdl name>_badval, which contains the badvalue for that piddle (see
get_xsdatapdecl() in PP/PdlParObjs.pm). Thanks to Tuomas' suggestion, 3 
macros have been set up to provide easy access:

  '$ISBAD($a(n=>1))'  expands to '$a(n=>1) == a_badval'
  '$ISGOOD($a())'                '$a()     != a_badval'
  '$SETBAD($bob())'              '$bob()    = bob_badval'

(well, the $a(...) is expanded as well). This means that you can change
   Code => '$a() = $b() + $c();'
to
   BadCode => 'if ( $ISBAD($b()) || $ISBAD($c()) ) { 
                 $SETBAD($a()); 
               } else {
                 $a() = $b() + $c();
               }'
leaving Code as it is. PP::PDLCode will then create a loop something like
   if ( __trans->bvalflag ) {
        threadloop over BadCode
   } else { 
        threadloop over Code
   }
it's probably easier to just look at the .xs file to see what goes on.

I haven't provided macros for more complicated cases - such as would be
useful in the EQUIVCPOFFS_BAD macro (see EquivCPOffsCode and Code rules
in PP.pm).

NOTE: the above relies on horrible hacking of PDL::PP::Code and
PDL::PP::ComplexThreadLoop, since I couldn't see a way, using the current 
scheme, to get a loop like the above. If you can, please implement!

Similar to BadCode, there's BadBackCode, and BadRedoDimsCode, although
these haven't been used yet.

EquivCPOffsCode has been changed to understand bad values - with a
$EQUIVCPOFFS_BAD macro as well - although I don't really understand what 
I'm doing here!

Please note that the current design is based on my failure to understand
what the xxx_redodims(), xxx_copy(), xxx_free() functions that are 
created by PP do. 

There's (to my mind at least!) issues about how to handle comparison
operators - see TODO.bpix and the comments near zcover() in primitive.pd.

Other notes
===========

The build process has been affected. The following files are
now created during the build:
  Basic/Core/Dev.pm      by mkdev.pl
             pdlcore.h      pdlcore.h.PL
             pdlapi.c       pdlapi.c.PL
             Core.xs        Core.xs.PL
             Core.pm        Core.pm.PL     

We can't use Dev.pm.PL, since Dev.pm is used by the Makefile.PL's,
so must be created as soon as possible.

Several new files have been added:
  README.bpix
  Changes.bpix
  IMPLEMENTATION.bpix

  t/bad.t

  Basic/Bad/
  Basic/Bad/Makefile.PL
            bad.pd
