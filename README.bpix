--------------------------------------------------------------------------------

                        Bad value support in PDL

 Doug Burke (burke@ifa.hawaii.edu) & ...
 last update: 07/12/00

--------------------------------------------------------------------------------

What are bad values and why should I bother with them?
======================================================

Sometimes it's useful to be able to specify a certain value is 'bad' or 
'missing'; for example CCDs used in astronomy produce 2D images which are not
perfect, since certain areas contain invalid data. Whilst PDL's powerful index
routines and all the complicated business with dataflow, slices, etc etc mean 
that these regions can be ignored in processing, it's awkward to do. It would
be much easier to be able to say '$c = $a + $b' and leave all the hassle to the
computer.

However, if you're not interested in this, then you may (rightly) be concerned 
with how this affects the speed of PDL, since the overhead can be large.

Enter PDL's WITH_BADVAL configuration option -  if set to 0 or undef, the 
bad-value support is ignored and you won't see any slow-down of code.

The routines which support bad values are written to be as fast as possible -
particularly when operating on piddles which do not contain bad values.

You may also ask 'well, my computer supports IEEE NaN, so I already have this'.
Well, yes and no - many routines, such as y=sin(x), will propogate NaN's 
without the user haveing to code differently, but routines such as qsort, or
finding the median of an array, need to be re-coded to handle bad values.
Currently we do not use NaN values, but it's a high priority to allow this, 
since it will speed up the code. See the section in IMPLEMENTATION.bpix for
more details.

--------------------------------------------------------------------------------

A quick overview
================

The intention is to:
 a) not significantly affect PDL for users who don't want bad value support
 b) be as fast as possible when bad value support is required

If you never want bad value support, then you set WITH_BADVAL to 0 in 
perldl.conf; PDL then has no bad value support compiled in, so will be as fast
as it used to be.

However, in most cases, the bad value support has a negligible affect on speed,
so you should set WITH_CONFIG to 1! One exception is if you are low on memory,
since the amount of code produced is larger (I haven't checked to see by how
much, so it may actually not be a significant amount).

To find out if PDL has been compiled with bad value support, look at the values
of either $PDL::Config{WITH_BADVAL} or $PDL::Bad::Status - if true then
it has been.

To find out if a routine supports bad values, use the 'badinfo' command in
perldl or the '-b' option to pdlsoc. This facility is currently a 'proof of
concept' (or, more realistically, a quick hack) so expect it to be rough 
around the edges.

Each piddle contains a flag - accessible via $pdl->badflag - to say whether
there's bad data present: 

  If false/0, which means there's no bad data here, the code supplied by the 
  CODE option to pp_def() is executed. This means that the speed should be 
  very close to that obtained with WITH_BADVAL=0, since the only overhead is 
  several accesses to a bit in the piddles state variable.

  If true/1, then this says there MAY be bad data in the piddle, so use the
  code in the BADCODE option (assuming that the pp_def() has been updated to
  have a BADCODE option). You get all the advantages of threading, a with the
  CODE option, but it will run slower since you are going to have to handle
  the presence of bad values.

If you create a piddle, it will have its bad-value flag set to 0. To change 
this, use $pdl->badflag($new_bad_status), where $new_bad_status can be 0 or 1.
When a routine creates a piddle, it's bad-value flag will depend on the input
piddles: unless over-ridden (see the CopyBadStatusCode option to pp_def), the 
bad-value flag will be set true if any of the input piddles contain bad values.

NOTE: propogation of the badflag

 If you change the badflag of a piddle, this change is propogated to all
 the *children* of a piddle, so
   $a = zeroes(20,30);
   $b = $a->slice('0:10,0:10');
   $c = $b->slice(',(2)');
   print ">>c: ", $c->badflag, "\n";
   >>c: 0
   $a->badflag(1);
   print ">>c: ", $c->badflag, "\n";
   >>c: 1

 *No* change is made to the parents of a piddle, so
   print ">>a: ", $a->badflag, "\n";
   >>a: 1
   $c->badflag(0);
   print ">>a: ", $a->badflag, "\n";
   >>a: 1

 I think that:
   a) the badflag can ONLY be cleared IF a piddle has NO parents,
      and that this change will propogate to all the children of that
      piddle
   b) $a->badflag(1) should propogate the badflag to BOTH parents and
      children.

 This wouldn't be hard to implement. Does it make sense though?

Currently, there is one bad value for each datatype. This may well change to
allow a per-piddle bad value, since it shouldn't affect the code speed, but 
shouldn't affect the following (indeed it will solve one problem).

 The orig_badvalue() method returns the compile-time value for a given 
 datatype. It works on piddles, PDL::Type objects, and numbers - eg
   $pdl->orig_badvalue(), byte->orig_badvalue(), and orig_badvalue(4).
 It also has a horrible name...

 To get the current bad value, use the badvalue() method - it has the same
 syntax as orig_badvalue().

 There's also badvalue_as_pdl(), which returns the bad value in a 0D piddle
 with badflag set to 1. This function may go away...

 To change the current bad value, supply the new number to badvalue - eg
   $pdl->badvalue(2.3), byte->badvalue(2), badvalue(5,-3e34). 
 Note that the value is silently converted to the correct C type, and
 returned - ie byte->badvalue(2.3e34) returns 255 on my solaris machine.
 
TODO:
   $pdl->badvalue(2.3) should update $pdl to use 2.3 as it's bad value. 
   Currently $pdl will be left using the old bad value.

Note that changes to the bad value are NOT propogated to previously-created
piddles - they will still have the bad value set, but suddenly the elements
that were bad will become 'good', but containing the old bad value.
This would NOT be a problem with a per-piddle bad value.

See PDL::Bad for useful routines for working with bad values.

--------------------------------------------------------------------------------

 README.bpix         - this file
 IMPLEMENTATION.bpix - details of how the bad-value support in implemented 
 TODO.bpix           - bugs/wish list/general thoughts

